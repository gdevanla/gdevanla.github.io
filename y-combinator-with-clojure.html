<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="author" content="Guru Devanla">
        <title>Y-Combinator with Clojure</title>

        <!--web fonts-->
        <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Belgrano" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="/theme/css/main.css" />

           <script type="text/javascript">

               var _gaq = _gaq || [];
                 _gaq.push(['_setAccount', 'UA-45968778-1']);
                 _gaq.push(['_trackPageview']);

                 (function() {
                   var ga = document.createElement('script'); ga.type =
                   'text/javascript'; ga.async = true;
                   ga.src = ('https:' == document.location.protocol ?
                   'https://ssl' : 'http://www') +
                   '.google-analytics.com/ga.js';
                   var s = document.getElementsByTagName('script')[0];
                   s.parentNode.insertBefore(ga, s);
                 })();

               </script>

        <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
              Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-45968778-2', 'gdevanla.github.io');
              ga('send', 'pageview');

        </script>
</head>

<body>
    <header>
        <span><a class="title" href="/index.html"><h1>*code*</h1></a></span>
        <nav>
            <ul>
                    <li><a href="/index.html">posts</a></li>
                    <li><a href="/archives.html">archives</a></li>
                    <li><a href="/pages/who-am-i.html">about</a></li>
            </ul>
        </nav>
    </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h2>
        <a class="title" href="/y-combinator-with-clojure.html" rel="bookmark"
           title="Permalink to Y-Combinator with Clojure">Y-Combinator with Clojure</a></h2>
      <div class="extra-info">
                <abbr class="published" title="2014-02-23T18:28:22">
                    23 Feb 2014
                </abbr>
                In <a href="/category/functional-programming-clojure-algorithm.html">functional programming, Clojure, algorithm</a>.       </div><!-- /.entry-content -->

    </header>
    <p>I spent the past weekend working through the talk by Jim Weirich on the
Y-Combinator. The talk is available at <a href="http://www.infoq.com/presentations/Y-Combinator">InfoQ</a>. This talk
is similar to the Ruby <a href="http://www.youtube.com/watch?v=FITJMJjASUs">talk</a> he gave at RubyConf 2012.</p>
<p>This post is the gist of that demo. Jim does a phenomenal job of walking through the example. I have shared the gist
to make it easy to follow the demo.</p>
<p>Some neat things I got to learn from the talk are the refactoring techniques and how with these techqniques one could arrive at
the Y-Combinator. Staring at the Y-Combinator definition before this talk always made me wonder how Church could have arrived at
this definition. In this talk, you will also understand the simplicity of lambda calculus.</p>
<p>Refactoring in functional programming : Even though I have seen the techniques while factoring out variables, it was nice
to put names to such techniques. The four techniques you will hear about in the talk are)</p>
<ul>
<li>Tennent Correspondence Principle</li>
<li>Introducing Bindings</li>
<li>Wrapping functions</li>
<li>Inlining</li>
</ul>
<p>Just with these four techniques Jim shows how a naive implementation of a factorial function can be converted to pure lambda
calculus form. This conversion motivates the need for the combinator known as the Y-Combinator (generally called
<a href="http://en.wikipedia.org/wiki/Fixed-point_combinator">Fixed-Point Combinator</a>.</p>
<div class="gist">
    <script src='https://gist.github.com/9171085.js'></script>
    <noscript>
        <pre><code>;; This gist roughly transribes the demo
;; by Jim Weirich during his talk on Y-Combinator
;; called Y-Not.
;; http://www.infoq.com/presentations/Y-Combinator
;; Jim does a phenomenal job of explaining in the demo.
;; Therefore, this gist only attempts to provide
;; the code example from the poor quality video
;; The examples are simplified at some places
;; based on how I tried to understand it


;; Higher order functions

(do
   (def add1 (fn [n] (+ n 1)))
   (def mul3 (fn [n] (* n 3)))
   (mul3 (add1 10))
   )

;;33

;; introduce a Higher Order functions 'make-adder'
;; 'make-adder' returns a function that adds 1

;; introduce 'compose' as a higher order function
;; 'compose' takes two functions as arguments and returns
;; a composition of those 2 functions
;; 'compose' is a higher order function in its parameters
;; as well as its return value

(do
   (def make-adder
     (fn [x]
       (fn [n] (+ n x))))

   (def compose
     (fn [f, g]
       (fn [n] (f (g n)))))

   (def add1 (make-adder 1))
   (def mul3 (fn [n] (* n )))

   (def mul3add1 (compose mul3 add1))

   (mul3add1 10)
   )
;;11

;; Functional refactorings
;; 1) Tennent Correspondence principle
;; 2) Introduce Binding
;; 3) Wrap a function
;; 4) Inlining

;;let use the simple example and take it through all
;;4 refactoring steps

(do
   (def add
     (fn [n] ( + n 1))   ;; change this using tenent correspondence principle
     )

   (add 1 2)
   )


;; Tennent Correspondence Principle
;; wrap an expression 's-exp' in a lambda expression (fn [] s-exp) and
;; immediately call it ((fn [] s-exp)) [notice the extra braces]

 (do
   (def add
     (fn [n] ((fn [] ( + n 1))))  ;;Tennent
     )

   (add 1)
   )

;;2

;; 2) Introduce Binding
;; Add an argument to a function, that is not bounded already
;; Wrap sexp => (fn [n] (+ n1)) with ((fn [v] sexp) 1).
;; 1 is a dummy variable that is never used, therefore no change in behavior
;;

 (do
   (def add
     ((fn [v] (fn [n] (+ n 1))) 1)  ;;binding v
     )

   (add 1)
   )

;; 3) Wrap function
;; This refactoring just wraps around a function and calls the
;; wrapped function with the value pass to it.
;; sexp' = (fn [x] ...) =>  (fn [y] ((sexp') y))

 (do
   (def add
     ((fn [y]
        ((fn [v] (fn [n] (+ n 1))) 1))  ;;function wrapping
      y)
     )

   (add 1)
   )

;; 4) inlining
;; take defintion of the function and replace any call to that definition
;; with the definition
;; Here we replace the definition of add into (add 1)

(do
  (((fn [y]
        ((fn [v] (fn [n] (+ n 1))) 1)) ;;inlining
      y) 1)
   )

;;the above expression does not have any names function
;;hence forms a nice lambda expression

;; Done with 4 refactoring on the original example

;; Example of arriving at Y-combinator
;; using the example of recursive factorial function

;; Start with the naive implementation
;; of factorial function

(def fact-1 (fn [n] (if (zero? n) 1 (* n (fact-1 (dec n))))))

(fact-1 10)
;;3628800

;; try converting the above expression
;; into a pure lambda expression without any named functions
;; try function inlining

(fact-1 (fn [n] (if (zero? n) 1 (* n (fact-1 (dec n))))))  ;; compiler error

;;but the above expression does not work. Since, the compiler
;;does not find fact-1

;; Try passing function name as parameter
;; Create a higher-order function that takes the definition of
;; fact-1 and return another function

(def make-fact (fn [fact-1]
                    (fn [n] (if (zero? n) 1 (* n (fact-1 (dec n)))))))


(make-fact ???) ;; in catch-22 mode, we still can't get fact-1

;; Get hold off a partial defintion of factorial
;; that is a factorial function works only for smaller domain of inputs.

;;define eror
(def error (fn [n] (throw "This should never get called")))

;;call the function the the factorial function the 'improver'
(def improver
  (fn [partial]
    (fn [n] (if (zero? n) 1 (* n (partial (dec n)))))))

;; factorial works for 0
(def f0 (improver error))
(f0 0)
;;1

(f0 1)  ;; fails

;;but we can use f0 to make g1

(def f1 (improver f0))
(f1 1)
;;1

;;so we can go on with the next factorial..
(def f2 (improver f1))
(f2 2)

(def f3 (improver f2))
(f3 3)

;; So far: introduced a partial function with a placeholder function 'error'
;; which never gets called since we build the first version of the function
;; using the base value of 0.

;; Generalize the improver
;; we can generalize f1, f2, ...fn with fx, fx takes improver
;; as its parameter in the above examples. Therefore,

(def fx
  ((fn [improver] (improver error))
   (fn [partial]
     (fn [n] (if (zero? n) 1 (* n (partial (dec n))))))
   )
  )

;;but version again works for only (fact 0)
(fx 0)
;;0

(fx 1)
;;error

;; replace (improver error) with (improver improver)
(def fx
  ((fn [improver] (improver improver)) ;;change here
   (fn [improver] ;;change here
     (fn [n] (if (zero? n) 1 (* n ((improver improver)(dec n)))))) ;;change here
   )
  )

(fx 5)

;; So, whats happening above is we are setting up a lazy
;; sequence of recursive calls. For a call like
;; each subsequent calls sets up the improver for a smaller value
;; of n. Thefore, the inner most call will be similar to the call
;; ((improver improver) 0), when the recursive part of the function
;; is not evaluated.

;; replace improver with x
((def fx
   ((fn [x] (x x))
    (fn [x]
      (fn [n] (if (zero? n) 1 (* n ((x x) (dec n)))))))
   ) 5)

;;120

;; semantics of factorial and recursion is mixed up here
;; we want to get two pieces of the factorial function out
;; a) the base case and 2) the recursive call

;; In refactoring these 2 pieces out, we will use a bind variable and pass these pieces
;; into the function using the bind variable. To achive this we need to use the functional
;; refactoring techniques. First we will wrap the sexp that needs to be refactored out,
;;  perform Tennent Correspondence Principle on the outer sexp, then we
;; we create a binding and then pass a value to that binding. Here the value will be the
;; piece we are factoring out. Finally, we will do the inlining


;;let refactor out the recursive piece first
;; we want to tease out (x x) =>  (fn [] ((x x)) v)
;; here we see we extracted out (x x) by
(((fn [x] (x x))
  (fn [x]
    ((fn [code]   ;; tennent correspondence and binding
       (fn [n] (if (zero? n) 1 (* n (code (dec n))))))
     (fn [v] ((x x) v)))
    ))
  5)


;; Factor out '(fn [n] (if (zero? n) 1 (* n (code (dec n)))))'.
;; Perform the same number of steps tennent, bind, wrap and pass the argument

;;tennent correspondence principle
(((fn [x] (x x))

  ((fn []
     (fn [x]
            ((fn [code]
               (fn [n] (if (zero? n) 1 (* n (code (dec n)))))
               )
             (fn [v] ((x x) v)))
            )))
  )
  5)
;; 120

;; before we bind, we rename code to partial
(((fn [x] (x x))
  ((fn []
     (fn [x]
            ((fn [partial]
               (fn [n] (if (zero? n) 1 (* n (partial (dec n)))))
               )
             (fn [v] ((x x) v)))
            )))
  )
  5)
;; 120

;; Notice both the base and recursive parts of
;; factorial function was extracted

(((fn [code] ;;exract into y
    ((fn [x] (x x))
     (fn [x]
       (code
        (fn [v] ((x x) v)))
       )))
    (fn [partial] ;;extract into fact-improver
      (fn [n] (if (zero? n) 1 (* n (partial (dec n)))))))
 5)


;;extract two pieces from above expressions
(def y
  (fn [code]
    ((fn [x] (x x))
     (fn [x]
       (code
        (fn [v] ((x x) v)))
       ))))

(def fact-improver
  (fn [partial]
      (fn [n] (if (zero? n) 1 (* n (partial (dec n)))))))

((y fact-improver
  )
 5)


;;or

(def fact (y fact-improver))

(fact 5)
;;120

;;therefore here y is the y-combinator
;;usually called the z-combinator or applicative order y-combinator

;; Start formating y the same way the y-combinator is defined on
;; wikipedia
;; rename code to f
(def y
  (fn [f]
    ((fn [x] (x x))
     (fn [x]
       (f
        (fn [v] ((x x) v)))
       ))))

;; calling f on (x x ) does not change anything
;; since (x x) returns a fixed-point function
(def y
  (fn [f]
    ((fn [x] (f (x x)))
     (fn [x]
       (f
        (fn [v] ((x x) v)))
       ))))

;; tennent principle, binding and wrap on (x x)
(def y
  (fn [f]
    ((fn [x] (f (fn [v] ((x x) v))))
     (fn [x]
       (f
        (fn [v] ((x x) v)))
       ))))

;;rearranging, we have a definition similar to
;;the one available on wikepedia
(def y
  (fn [f]
    ((fn [x] (f (fn [v] ((x x) v))))
     (fn [x] (f (fn [v] ((x x) v)))
       ))))
</code></pre>
    </noscript>
</div>


  </article>
</section>
    <footer>
        <hr>
        <div class="social">
            <ul>
                <li><a href="http://github.com/gdevanla">GitHub</a></li>
                <li><a href="http://twitter.com/grdvnl">Twitter</a></li>
            </ul>
            <ul>
                <li>
                    Powered by Pelican
                </li>
            </ul>
        </div><!-- /.social -->


<!-- 
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-45968778-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
 -->
<script type="text/javascript">
    var disqus_shortname = 'devanla';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());

</script>
<div id="disqus_thread" class="body"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO
  YOUR WEBPAGE * * */
  var disqus_shortname = 'devanla';
  //required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname +  '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] ||
  document.getElementsByTagName('body')[0]).appendChild(dsq);

  })();
</script>
<noscript>Please enable JavaScript to view
  the <a href="http://disqus.com/?ref_noscript">comments powered
    by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments
  powered by <span class="logo-disqus">Disqus</span></a>

</body>
</html>