<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="author" content="Guru Devanla">
        <title>DataFrame use Anti-Pattern</title>

        <!--web fonts-->
        <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Belgrano" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="/theme/css/main.css" />
        <!-- <link rel="stylesheet" href="/theme/css/pygment.css"/> -->
        <link rel="stylesheet" href="/theme/css/default.css"/>


           <script type="text/javascript">

               var _gaq = _gaq || [];
                 _gaq.push(['_setAccount', 'UA-45968778-1']);
                 _gaq.push(['_trackPageview']);

                 (function() {
                   var ga = document.createElement('script'); ga.type =
                   'text/javascript'; ga.async = true;
                   ga.src = ('https:' == document.location.protocol ?
                   'https://ssl' : 'http://www') +
                   '.google-analytics.com/ga.js';
                   var s = document.getElementsByTagName('script')[0];
                   s.parentNode.insertBefore(ga, s);
                 })();

               </script>

        <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
              Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-45968778-2', 'gdevanla.github.io');
              ga('send', 'pageview');

        </script>
</head>

<body>
    <header>
        <span><a class="title" href="/index.html"><h1>blog <| code </h1></a></span>
        <nav>
            <ul>
                    <li><a href="/index.html">posts</a></li>
                    <li><a href="/archives.html">archives</a></li>
                    <li><a href="/pages/who-am-i.html">about</a></li>
                    <li><a href="/pages/books.html">book</a></li>
            </ul>
        </nav>
    </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h2>
        <a class="title" href="/dataframe-use-anti-pattern.html" rel="bookmark"
           title="Permalink to DataFrame use Anti-Pattern">DataFrame use Anti-Pattern</a></h2>
      <div class="extra-info">
                <abbr class="published" title="2018-06-11T00:00:00-07:00">
                    06-11-2018
                </abbr>
                In <a href="/category/pandas-namedtuple-static-typing.html">Pandas, namedtuple, static typing</a>.       </div><!-- /.entry-content -->

    </header>
    <h1>Introduction</h1>
<p>Panda's DataFrame is a versatile data structure. It is a Swiss-army
like data structure that lets you perform a variety of
operations. When I am on ipython interactive console prototyping new
features, I can confidently throw any weird operation on to the
Panda's dataframe and more often that not, it just works. Creating a
<code>DataFrame</code> using a variety of data structures as input, slicing and dicing to the
heart's content all comes easily. But, with this kind of flexibility
and power, there is a tendency to reach out to the DataFrame for all
kinds of tasks in production code as well. This leads to what I keep
referring to as <code>dictionary-oriented</code> programming.</p>
<p>In this style of programming, one goes about creating a <code>DataFrame</code> or
<code>Series</code>. Then this object is passed around to
other functions that may/or may not create copies of this data-frame/series
while adding additional columns. The convenience of this approach is that
the flow of data and calculation is documented in the columns of the
dataframe. The logs and actual calculation are are mixed up in one
data structure. It is really convenient to use this approach to
quickly produce results as well as provide enough information to
power users who consume this data. Here, by power users I mean
users(say analysts/quants) who directly analyze the result in Excel
or with any of their power tools using the output from programs that
use and produce output from these dataframes.</p>
<p>There are 2 parts to the above discussed use of dataframes. If the
data we deal with is 'tall' or 'wide' and we perform a lot of vector
operations on this data-structure, then using dataframes likely is the
perfect tool for the job. And in Python, that is the best possible
tool you can use. But, this reasoning does not hold any more if you
are dealing with small pieces of data (say 10s of rows). While dealing
with that kind of data, it is desirable to move away from dataframes and just
use named-tuples and or any other light weight data structure. Using
dataframes, to deal with such data should be considered an
anti-pattern and that is the core proposition of this post.</p>
<h1>Dictionary-oriented programming - Anti-Pattern</h1>
<p>As I stated earlier using dataframe as a go-to data structure leads to
<code>dictionary-oriented programming</code>. It is easy to define columns and
grow the dataframe in terms of columns during the program flow. This
leads to incoherently typed programs. The dataframe is used as a
kitchen-sink and all columns are thrown into it as the program
organically evolves. This also makes if difficult to reason about
programs. To understand the final shape of the dataframe one needs to
peruse code across different function calls. Unless vector oriented
operations are required, and large data needs to be processed it is
sufficient to stick to simple data structures, eg. namedtuples.</p>
<p>In the following section I show a few statistics on how these two
approaches perform. Even in cases of better performance
characteristics of dataframe approach, it is still better not to reach
out the dataframe for the above stated reasons.</p>
<h1>Performance Comparison</h1>
<p>What follows is very simple comparison of creation and access
operations using namedtuples and dataframes for a small piece of data and for data
that spans to 150K entries.</p>
<h2>Creation</h2>
<h3>Creation using namedtuples</h3>
<div class="highlight"><pre><span></span>    <span class="c1"># Creating 5 entries using a namedtuple</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">X</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">))</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="p">[</span><span class="n">X</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">X</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">X</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span><span class="n">X</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span><span class="n">X</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)]</span>
    <span class="c1"># 1.94 µs ± 8.02 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span>
</pre></div>


<h3>Creation using DataFrame</h3>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">]))</span>
    <span class="c1"># 348 µs ± 1.75 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span>

    <span class="c1"># create dict upfront to eliminate the time needed to construct the dictionary</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">])</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># 347 µs ± 1.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span>
</pre></div>


<p>You will notice that named-tuple creation is a lot faster. <em>This speed-difference is surprising!</em> even after factoring for dictionary object creation. This is due to pandas itself creating a dictionary-like object which we are creating in the namedtuple approach. But, here the point is for the size of datasets we create, that rich datastructure may not be required.</p>
<p>Creating 150K named-tuple objects takes the same amount of time creating a dataframe with 5 records.</p>
<div class="highlight"><pre><span></span>    <span class="c1"># Creating 1K named tuple objects is close to creating 5 rows in Pandas</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="p">[</span><span class="n">X</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)]</span>
    <span class="c1"># 388 µs ± 2.18 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span>
</pre></div>


<p>But creating a dictionary to hold the namedtuples takes a lot more time and here time needed for dataframe creation seems to get smaller</p>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">8</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">X</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">150000</span><span class="p">)))}</span>
    <span class="c1"># 78.6 ms ± 268 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span>
</pre></div>


<p>Creating a dataframe which contains 150K rows</p>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">13</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">150000</span><span class="p">)),</span> <span class="n">b</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">150000</span><span class="p">)),</span> <span class="n">c</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150000</span><span class="p">)),</span> <span class="n">d</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">150000</span><span class="p">))))</span>
    <span class="c1"># 52.8 ms ± 550 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span>
</pre></div>


<p>It is also useful to note that while dealing with DataFrames, we are always creating a dictionary like structure even though that is not the case with namedtuple operations we are comparing against.</p>
<h3>Access operations</h3>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="n">named_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">X</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">150000</span><span class="p">)])}</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">9</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">named_dict</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
    <span class="c1"># 26.8 ns ± 0.119 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)</span>
</pre></div>


<p>Now, using a dataframe, creating 150K rows takes more than twice the time. Access time is still faster with Python dictionary.</p>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">33</span><span class="p">]:</span> <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">150000</span><span class="p">)),</span> <span class="n">b</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">150000</span><span class="p">)),</span> <span class="n">c</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150000</span><span class="p">)),</span> <span class="n">d</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">150000</span><span class="p">))))</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">16</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
    <span class="c1"># 74.4 µs ± 416 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)</span>
</pre></div>


<h3>Vector operations</h3>
<p>Here the performance is as expected. DataFrame approach is far better.</p>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">20</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">a</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">named_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="c1"># 11.5 ms ± 147 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">29</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1"># 475 µs ± 1.56 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span>
</pre></div>


<h3>Random access</h3>
<p>While accessing elements randomly, accessing values through the namedtuple is faster.</p>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">24</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="p">(</span><span class="n">named_dict</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">named_dict</span><span class="p">[</span><span class="mi">200</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">named_dict</span><span class="p">[</span><span class="mi">500</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># 240 ns ± 1.35 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">23</span><span class="p">]:</span> <span class="o">%</span><span class="n">timeit</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">200</span><span class="p">][</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">500</span><span class="p">][</span><span class="s1">&#39;a&#39;</span><span class="p">])</span>
    <span class="c1"># 246 µs ± 2.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span>
</pre></div>


<h1>DataFrame is still powerful</h1>
<p>I make the case to not use DataFrames when we need simple data objects to pass around. Once we need to manipulate and transform large datasets, slice and dice them, merge them and perform verctor operations that DataFrame is a powerful datastructure for those purposes.</p>
<h1>Benefits</h1>
<p>Using named-tuples are similar data structures, you get</p>
<ol>
<li>Immutability</li>
<li>Types are well-defined</li>
<li>Easier to refactor since it is easier to understand where and how the data is created and passed around</li>
<li>No more 'stringy' use of api to access columns</li>
</ol>


  </article>
</section>
    <footer>
        <hr>
        <div class="social">
            <ul>
                <li><a href="http://github.com/gdevanla">GitHub</a></li>
                <li><a href="http://twitter.com/grdvnl">Twitter</a></li>
            </ul>
            <ul>
                <li>
                    Powered by Pelican
                </li>
            </ul>
        </div><!-- /.social -->


<!--  -->

</body>
</html>