<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="author" content="Guru Devanla">
        <title>Read you a Scotty</title>

        <!--web fonts-->
        <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Belgrano" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="/theme/css/main.css" />
        <link rel="stylesheet" href="/theme/css/pygment.css"/>
        <link rel="stylesheet" href="/theme/css/emacs.css"/>


           <script type="text/javascript">

               var _gaq = _gaq || [];
                 _gaq.push(['_setAccount', 'UA-45968778-1']);
                 _gaq.push(['_trackPageview']);

                 (function() {
                   var ga = document.createElement('script'); ga.type =
                   'text/javascript'; ga.async = true;
                   ga.src = ('https:' == document.location.protocol ?
                   'https://ssl' : 'http://www') +
                   '.google-analytics.com/ga.js';
                   var s = document.getElementsByTagName('script')[0];
                   s.parentNode.insertBefore(ga, s);
                 })();

               </script>

        <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
              Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-45968778-2', 'gdevanla.github.io');
              ga('send', 'pageview');

        </script>
</head>

<body>
    <header>
        <span><a class="title" href="/index.html"><h1>blog <| code </h1></a></span>
        <nav>
            <ul>
                    <li><a href="/index.html">posts</a></li>
                    <li><a href="/archives.html">archives</a></li>
                    <li><a href="/pages/who-am-i.html">about</a></li>
                    <li><a href="/pages/books.html">book</a></li>
            </ul>
        </nav>
    </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h2>
        <a class="title" href="/read-you-a-scotty.html" rel="bookmark"
           title="Permalink to Read you a Scotty">Read you a Scotty</a></h2>
      <div class="extra-info">
                <abbr class="published" title="2017-05-22T06:09:27.110525-07:00">
                    05-22-2017
                </abbr>
                In <a href="/category/misc.html">misc</a>.       </div><!-- /.entry-content -->

    </header>
    <div xml:lang="en" class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="idm45784858018000"></a>Read you a Scotty</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Guru</span> <span class="surname">Devanla</span></h3></div></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><strong>Revision History</strong></th></tr><tr><td align="left">Revision 1.0</td><td align="left">2017-02</td><td align="left">GD</td></tr></table></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="#_prologue">1. Prologue</a></span></dt><dd><dl><dt><span class="section"><a href="#_about_the_book">1.1. About the book</a></span></dt><dt><span class="section"><a href="#_how_to_read_this_book">1.2. How to read this book</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_introduction">2. Introduction</a></span></dt><dt><span class="chapter"><a href="#_a_toy_scotty">3. A Toy Scotty</a></span></dt><dd><dl><dt><span class="section"><a href="#_first_iteration">3.1. First Iteration</a></span></dt><dt><span class="section"><a href="#_second_iteration">3.2. Second Iteration</a></span></dt><dt><span class="section"><a href="#_third_iteration">3.3. Third iteration</a></span></dt><dt><span class="section"><a href="#_fourth_iteration">3.4. Fourth Iteration</a></span></dt><dt><span class="section"><a href="#_fifth_iteration">3.5. Fifth Iteration</a></span></dt><dt><span class="section"><a href="#_sixth_iteration">3.6. Sixth Iteration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_sample_web_application">4. Sample Web Application</a></span></dt><dd><dl><dt><span class="section"><a href="#_entry_points_and_settings">4.1. Entry Points and Settings</a></span></dt></dl></dd><dt><span class="chapter"><a href="#routes">5. Declaring routes</a></span></dt><dt><span class="chapter"><a href="#_initializing_the_app">6. Initializing the App</a></span></dt><dt><span class="chapter"><a href="#_handling_requests">7. Handling requests</a></span></dt><dd><dl><dt><span class="section"><a href="#_acessing_request_parameters">7.1. Acessing Request Parameters</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_response">8. Response</a></span></dt><dt><span class="chapter"><a href="#_epilogue">9. Epilogue</a></span></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_prologue"></a>Chapter 1. Prologue</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_about_the_book"></a>1.1. About the book</h2></div></div></div><p>Part of a <span class="emphasis"><em>Read You A _</em></span>™ series.
© 2017 Guru Devanla</p><p><code class="literal">Scotty</code> is a relatively light-weight and interesting Haskell library
that can be used to inform novice Haskeller’s on how Haskell is used in the
real world. It provides the next level of reading to learn Haskell by
exploring the use of the powerful data structures Haskell provides.
The purpose of this book is to educate the reader beyond just learning
the basics of programming in Haskell. Many other books currently
available cover Haskell as a language at various depths. This book
follows the same spirit as the popular <span class="emphasis"><em>Real World Haskell(RWH)</em></span> book. The
<code class="literal">RWH</code> teaches the language and its use in real world scenarios. This
mini-book takes a deeper dive into one specific library and exposes the
reader to ways in which the various data structures in Haskell are put
to use.</p><p>The main objective of this book are as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Expose the reader
    to practical examples of use of Monads, Monad Transformers other power structures Haskell provides. Scotty
    library uses all the important monads(State, Maybe, Reader) taught
    in beginner Haskell books
</li><li class="listitem">
Looks at how these computation
    structures are organized in a purely functional manner
</li><li class="listitem">
Educate the reader, so that they can contribute to Scotty or
    build similar powerful libraries
</li></ol></div><p>At the minimum, after reading this book, the reader should be able to
reason with any code that is implemented using Scotty as the web
framework.</p><p>This book assumes basic familiarity of the reader with Haskell
concepts. Some of the advanced data structures that will be used in
the later parts of the book are introduced in the first chapter in a
gradual manner. But, this introduction does not provide detailed
explanations to concepts that are available in other general books on
Haskell.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_how_to_read_this_book"></a>1.2. How to read this book</h2></div></div></div><p>This book obviously uses extensive references to the Scotty source
code. Appropriate links are provided to the source code from the
sections where the code is discussed. It could be beneficial to clone
the <a class="ulink" href="https://github.com/scotty-web/scotty.git" target="_top">scotty</a> library from its
original source locally and explore the code as the book is read.</p><p>If you desire a <code class="literal">stack</code> enabled version, and the version the book
links the source code to, you can fork a version from
<a class="ulink" href="https://github.com/gdevanla/scotty.git" target="_top">scotty-forked</a>. This version is
forked so as to be able to refer to a consistent version of the
library from different sections in this book and also can be built using
<code class="literal">stack</code>.</p><p>Also, refer to the References section to refer to resources I used in
helping me understand the implementation. These resources can provide
the missing pieces not covered in this book.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_introduction"></a>Chapter 2. Introduction</h1></div></div></div><p>This chapter gives an overview of the approach taken in this book to
help the reader read through the  <code class="literal">Scotty</code> implementation. As stated, in
the Prologue this book is intended to help familiarize ourselves with
Haskell’s use in real-world. Therefore, the book will assume basic
knowledge in Haskell (acquired from books like LYH, Haskell from First
Principles etc).</p><p>One could go about reading an existing implementation in two
ways. One approach is to delve in right away and start looking through
the code until  we reach a logical starting point from where we can
anchor our understanding. From the logical point we could traverse the
code in different directions to enhance our understanding of the
code. Typically, we could take this approach if we find ourselves in a
situation where we want to learn the code by fixing a particular bug
or working on a new feature request.</p><p>Alternatively, we could sit back (if we have the time), and think
about the different ways of solving the problem at hand. Then, with
that idea, if we were to look at the existing implementation, the
process we went through could inform us on why the code
has been implemented the way it is.</p><p>For our purposes, to understand the <code class="literal">Scotty</code> implementation we will
take the latter approach. As a first step, we will create our own toy
implementation of the <code class="literal">Scotty</code> like framework. While we do this we
will reason about the limitations of our code during each iteration
and then improve on that. After a few iterations we will be at a
point, where our code will closely represent the overall design of the
original <code class="literal">Scotty</code> implementation. This exercise will both, make it
easy to read through the original implementation and also provide a
way of reasoning about the design decisions reflected in the
code.</p><p>Once we have our toy implementation in place, we start off by looking
at a simple web application built using <code class="literal">Scotty</code>. That will help us
define some terminology that we can use across the book. Some of this
terminology is also introduced while we implement our toy framework.</p><p>We then turn our attention to a simple type <code class="literal">Options</code> that will
introduce us to the
(<a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#L1)" target="_top"><code class="literal">Types.hs</code></a>.
The <code class="literal">Types.hs</code> module contains all the type definitions used by the
<code class="literal">Scotty</code> library.</p><p>One of the first things we need to do while defining a web application
is to map the different HTTP requests to methods that act on those
requests. We need a way to thread the requests through different
actions that serve request. We call this process <code class="literal">routing</code>. Therefore,
next we look at how this <code class="literal">routing</code> pipeline is created by <code class="literal">Scotty</code>.</p><p>Once the <code class="literal">routing</code> pipeline is created, then we can look at how the
user requests are threaded through these actions. This will give us
insight on how the <code class="literal">scotty state</code> is unwrapped before each request and
how the <code class="literal">requests</code> are passed on to the appropriate <code class="literal">action</code>.</p><p>Next, we look closely at a <code class="literal">routing</code> function in detail. The <code class="literal">routing</code>
function threads each request through an action by matching an <code class="literal">url</code>
pattern. We will also come across the <code class="literal">ActionT</code> monad that wraps an
environment (HTTP request information), the <code class="literal">response</code> and any error
values that may have been created.</p><p>By now we would have looked at most of the core <code class="literal">Scotty</code>
implementation. We will continue to explore the other parts of library
, namely <code class="literal">parameter handling</code> and <code class="literal">Response</code> creation and handling.</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_a_toy_scotty"></a>Chapter 3. A Toy Scotty</h1></div></div></div><p>In this section we will build a simple framework. This framework will
allow us to  creates route handlers that will represent the various
routes in a web app, provide default routes and also handle
errors. We will start with the simplest of setups and slowly work our
way towards a model that closely represents the design that is used
in Scotty. The hope is this step by step approach to a relatively
Scotty like model will help the reader understand the Scotty code
better when we start exploring the code in the later chapters.</p><p>Each iteration in this chapter is contained in one independent
module. Each module contains both the <code class="literal">server</code> code that will serve
requests and <code class="literal">client</code> code that will simulate any handlers the
client(user of our framework) provides. The client usually provides the
<code class="literal">route</code> handlers that contain the custom logic to handle requests. The
server code does the job of calling this handlers to process request
before sending back the response.</p><p>All the code examples discussed in this section is available at
<a class="ulink" href="https://github.com/gdevanla/scotty-from-ground-up/" target="_top">scotty-from-ground-up</a>.</p><p>The code can be compiled using <code class="literal">stack</code>. To run the example, in the
first iteration of this chapter follows these steps.</p><pre class="programlisting">stack build

stack exec main1</pre><p>Each module can be run as <code class="literal">stack exec mainX</code> , where <code class="literal">X</code> is the number
of the iteration. For example, the command to run the code in the
first iteration would be <code class="literal">stack exec main1</code>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_first_iteration"></a>3.1. First Iteration</h2></div></div></div><p>The code discussed in this iteration is available at
<a class="ulink" href="https://github.com/gdevanla/scotty-from-ground-up/blob/master/app/Main1.hs" target="_top">Main1.hs</a>.</p><p>Our first task is to declare some of the data types we will need.</p><pre class="programlisting">import qualified Control.Monad.Trans.State.Strict as ST
import Data.List
import Control.Monad

type Route = String -&gt; String

data AppState = AppState { routes::[Route]}

type AppStateT = ST.State AppState</pre><p>The <code class="literal">Route</code> type will be a set of routing functions the client can add
to handle different requests. We will have to capture the list of
<code class="literal">routes</code> provided by the client. We do that by wrapping the <code class="literal">Route</code>
type in  <code class="literal">AppState</code>. Since, we will be creating the list of <code class="literal">Routes</code>
during runtime we wrap our <code class="literal">AppState</code> in a <code class="literal">State</code> monad. We will
update this state monad as a first step when the application is run.</p><p>As part of the framework methods, we want the user to be able to
declare all the routes that need to be checked to handle any
request. We let the user invoke <code class="literal">myScotty</code> with the function that
declares all the routes of the app. Our first iteration of the
framework functions will look as follows:</p><pre class="programlisting">--  framework methods

addRoute' :: Route -&gt; AppState -&gt; AppState
addRoute' mf s@AppState {routes = mw} = s {routes = mf:mw}

addRoute mf = ST.modify $ \s -&gt; addRoute' mf s

runMyApp :: Monad m =&gt; String -&gt; ST.State AppState a -&gt; m String
runMyApp initial_string my_app = do
  let s = ST.execState my_app AppState{ routes = []}
  let output = foldl (flip ($)) initial_string (routes s)
  return $ output

myScotty my_app = do
  putStrLn "Please type in the request"
  putStrLn "(one of 'handler1', 'handler2', 'handler3', 'buggy' or any string for default handling)"
  request &lt;- getLine
  unless (request == "q") $ do
    let response = runMyApp request myApp
    case response of
      Just x -&gt; putStrLn x
      Nothing -&gt; putStrLn "Error"
    main</pre><p>Here, the client will invoke ‘myScotty` with a function that returns
`AppStateT ()’. An example implementation of route handlers that uses
the simple framework will be</p><pre class="programlisting">-- client functions
constructResponse :: [String] -&gt; String
constructResponse = unwords

routeHandler1 :: String -&gt; String
routeHandler1 request =
  constructResponse [
  "\nrequest in handler1: got " ++ request]

routeHandler2 :: String -&gt; String
routeHandler2 request = constructResponse [
      "\n\trequest in handler2 got :" ++ request]

routeHandler3 :: String -&gt; String
routeHandler3 request = constructResponse [
  "\n\t\trequest in handler3:" ++ request]

myApp :: AppStateT ()
myApp = do
  addRoute routeHandler1
  addRoute routeHandler2
  addRoute routeHandler3</pre><p>Here as a client of the framework we will create three functions
<code class="literal">routeHandlerX</code> functions that will be the handlers for processing a
respective requests. We will add these route handlers using the
<code class="literal">addRoute</code> method in <code class="literal">myApp</code>.  The <code class="literal">myApp</code> will be the argument to
<code class="literal">myScotty</code> function provided by the framework.</p><p>Finally, our <code class="literal">main</code> will be</p><pre class="programlisting">main :: IO ()
main = myScotty myApp</pre><p>Here we call <code class="literal">myScotty</code> and provide the list of handlers that can be
used to process requests.</p><p>Now let us look closely at what is happening in our toy framework
methods. You can ignore what is happening in <code class="literal">main</code> for now. In the
<code class="literal">main</code> function we just loop around and wait for user input to be
processed.  The functions of interest to us would be <code class="literal">addRoute</code></p><pre class="programlisting">addRoute' :: Route -&gt; AppState -&gt; AppState
addRoute' mf s@AppState {routes = mw} = s {routes = mf:mw}

addRoute mf = ST.modify $ \s -&gt; addRoute' mf s

runMyApp :: Monad m =&gt; String -&gt; AppState -&gt; m String
runMyApp initial_string my_app = do
  let output = foldl (flip ($)) initial_string (routes my_app)
  return $ output

myScotty my_app = do
  let app_state = ST.execState my_app AppState{routes=[]}
  userInputLoop app_state</pre><p>The <code class="literal">main</code> function, applies <code class="literal">myScotty</code> to myApp. The <code class="literal">myScotty</code>
function first sets up the state of AppState. The <code class="literal">app_state</code> values
has the list of router handlers that were declared in <code class="literal">myApp</code>. When
<code class="literal">myApp</code> is evaluated, each expression in <code class="literal">myApp</code> calls <code class="literal">addRoute</code>
which modifies the state of <code class="literal">AppState</code>. Therefore, in <code class="literal">myScotty</code> when
we <code class="literal">execState</code>, the AppState objects has all the <code class="literal">routes</code> stored in
the <code class="literal">routes</code> attribute.</p><p>After we <code class="literal">execState</code> and set up the state of <code class="literal">AppState</code>, we are ready
to run a loop (that simulates a server) and start handling user
requests. In <code class="literal">userInputLoop</code>, after accepting the input string from
the <code class="literal">user</code>, we apply <code class="literal">runMyApp</code> to the user input and pass along our
<code class="literal">AppState</code> value that has all the routes stored in it. The <code class="literal">runMyApp</code>
function folds over the list of <code class="literal">routes</code> and applies each <code class="literal">route</code>
to the previous <code class="literal">request</code> string passed to it.</p><pre class="programlisting">userInputLoop app_state = do
  putStrLn "Please type in the request"
  putStrLn "(one of 'handler1', 'handler2', 'handler3', 'buggy' or any string for default handling)"
  request &lt;- getLine

  unless (request == "q") $ do
    let response = runMyApp request app_state
    case response of
      Just x -&gt; putStrLn x
      Nothing -&gt; putStrLn "Error"
    main</pre><p>Let’s run the module and provide some input at the prompt.</p><pre class="programlisting">stack build

stack exec main1</pre><p>You will notice, that this is not how we want apply <code class="literal">routes</code> to a user
request. We only want the user <code class="literal">request</code> processed by one route. But,
hang on. We do this to help us build towards what we ultimately need.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_second_iteration"></a>3.2. Second Iteration</h2></div></div></div><p>We notice that in the first iteration our code did not do a good job
of processing requests only with one handler.  We will fix that in this iteration.
To fix that, we need each <code class="literal">routeHandler</code> to specify a condition on which it
should be called to  process the request. The code for the second
iteration is available at
<a class="ulink" href="https://github.com/gdevanla/scotty-from-ground-up/blob/master/app/Main2.hs" target="_top">Main2.hs</a>.</p><p>First we introduce a few more type synonyms to help us in the
process. We do this so that we can structure computation in
such a way that if one route fails to process the request (since
the request does not meet the condition) we want to be able to chain
our call to the next router. This will become clear when we review the
<code class="literal">route</code> function. Also, keep in mind that some of the design decisions
we make here are tuned to get us to a toy framework that closely
resembles the structure in the actual implementation of Scotty.</p><pre class="programlisting">type Application = String -&gt; String
type Route = Application -&gt; Application</pre><p>We will talk more on this type when we discuss the <code class="literal">route</code> function.
We make a change to the <code class="literal">addRoute</code> function where instead of calling
<code class="literal">addRoute'</code> directly, we call a function called <code class="literal">route</code>. This is where
the interesting stuff happens in this iteration.</p><p>Let’s take a look at the <code class="literal">route</code> method.</p><pre class="programlisting">route :: Application -&gt; (String -&gt; Bool)
  -&gt; Route
route mw pat mw1 input_string =
  let tryNext = mw1 input_string in
  if pat input_string
  then
    mw input_string
  else
    tryNext</pre><p>The <code class="literal">route</code> method takes an handler function which is of type
<code class="literal">Application</code> or <code class="literal">String-&gt;String</code>. This type is the <code class="literal">routeHandler</code> the
client provides. The <code class="literal">route</code> method captures the <code class="literal">routeHandlers</code> in
its closure. We call these routeHandlers the <code class="literal">action</code>. The second
parameter to this function is the predicate that needs to be <code class="literal">True</code>
for this action to be called. When the call to <code class="literal">route</code> from <code class="literal">addRoute</code>
returns, we have a function of type <code class="literal">Route</code>. But, what is this <code class="literal">Route</code></p><pre class="programlisting">Route</pre><p>reduces to</p><pre class="programlisting">(Application) -&gt; (Application)</pre><p>reduces to</p><pre class="programlisting">(String -&gt; String) -&gt; String -&gt; String</pre><p>Therefore,  what gets added to the <code class="literal">routes</code> attribute is a function
(that has the <code class="literal">action</code> or <code class="literal">routeHandler</code> in its closure), and takes
another <code class="literal">Application</code> as a parameter along with the <code class="literal">String</code> which
will be our <code class="literal">Request</code>.</p><p>The <code class="literal">route</code> function, calls the enclosed <code class="literal">routeHandler</code> if the
predicate is satisfied, else the call is chained to the next
<code class="literal">Application</code>.  We can see this action unfold in the foldl operation
used in <code class="literal">runMyApp</code>.</p><pre class="programlisting">runMyApp def app_state request = do
  let output = foldl (flip ($)) def (routes app_state) request
  return output</pre><p>The <code class="literal">def</code> here is the <code class="literal">defaultRoute</code> handler. You notice that as this
function folds the each value is <code class="literal">routes</code> is called with the next
value in <code class="literal">routes</code> and the <code class="literal">request</code> string. Please take a moment to
understand this. The core part of Scotty happens around this function,
where the processing of <code class="literal">actions</code> are setup.  You should try to list
the values of <code class="literal">routes</code> as they get created and then fold over those
values and see how the type checks out. As a new user to Haskell this
is an interesting pattern I came across. The <code class="literal">types</code> checkout as the
recursive nature of calls unfold. The <code class="literal">tryNext</code> function is called
recursively until a particular predicate is met or else in the end the
default route handler is called.</p><p>The client functions remain the same, except we change the response
and also align the types to the new <code class="literal">Application</code> type.</p><p>Try running this example with suggested input and then with some random input.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_third_iteration"></a>3.3. Third iteration</h2></div></div></div><p>In the third iteration, we switch the return type of route
handlers. We will update the route handlers to return a <code class="literal">Maybe</code>
value. That way, if the value returned is <code class="literal">Nothing</code> a default error
handler can be invoked later on.</p><p>For this we do a couple of changes to the code from the second
iteration. The full code for this iteration is available at
<a class="ulink" href="https://github.com/gdevanla/scotty-from-ground-up/blob/master/app/Main3.hs" target="_top">Main3.hs</a>.</p><p>We first update the type variable <code class="literal">Application</code> to return a <code class="literal">Maybe</code>
value rather than a <code class="literal">String</code>. For clarity we also introduce two other
type synonyms, namely, <code class="literal">Request</code> and <code class="literal">Response</code></p><pre class="programlisting">type Response = Maybe String
type Request = String

type Application = Request -&gt; Response</pre><p>Then we add a default error handler that will be invoked if any of the
<code class="literal">routeHandler</code> return a <code class="literal">Nothing</code> value.</p><pre class="programlisting">errorHandler :: Request -&gt; Response
errorHandler request = Just $ constructResponse [
  request, "Nothing returned from one of the handlers"]</pre><p>We then update the <code class="literal">route</code> method from second iteration to handle the
<code class="literal">Maybe</code> return values. Notice that if a <code class="literal">routeHandler</code> was invoked and
if the returned <code class="literal">Response</code> from the <code class="literal">routeHandler</code> was a <code class="literal">Nothing</code>
value, then the <code class="literal">errorHandler</code> is invoked.</p><p>We also update the types of all the framework function to reflect the
change of the response type from <code class="literal">String</code> to <code class="literal">Maybe String</code>.</p><p>Now, on the client side, we update all of <code class="literal">routeHandlers</code> to return a
<code class="literal">Maybe</code> value as a <code class="literal">Response</code>.  To show how our change works, the
<code class="literal">routeHandler2</code> has been updated to return <code class="literal">Nothing</code>.</p><pre class="programlisting">routeHandler1 :: Request -&gt; Response
routeHandler1 request =
  Just $ constructResponse [
  "request in handler1: got " ++ request]

routeHandler2 :: t -&gt; Maybe a
routeHandler2 request = Nothing

routeHandler3 :: Request -&gt; Response
routeHandler3 request =
  Just $ constructResponse [
  "request in handler3:" ++ request]

defaultRoute :: Request -&gt; Response
defaultRoute request =
  Just $ constructResponse [
  request , "processed by defaultRoute"]</pre><p>Try running the program,</p><pre class="programlisting">stack build
stack exec main3</pre><p>When the request string passed to the program is <span class="emphasis"><em>handler2</em></span>, then the
<code class="literal">routeHandler2</code> is called with the request string. Since,
routeHandler2 returns a <code class="literal">Nothing</code> value, the <code class="literal">errorHandler</code> is
called and no other <code class="literal">routeHandlers</code> is invoked from this point for
this <code class="literal">Request</code>.</p><pre class="programlisting">$ stack exec main3
Please type in the request
(one of 'handler1', 'handler2', 'handler3', 'buggy' or any string for
default handling)
handler2
Request=handler2, Response=Nothing returned from one of the handlers</pre><p>You will notice that even though we were able to handle <code class="literal">Nothing</code>
values returned from some routeHandlers, we still do not handle any
exceptions that could be thrown from the <code class="literal">routeHandlers</code>. We
will be taking care of that in later iterations of this code. Also, as
is the case with returning <code class="literal">Nothing</code> values, the nature of error is
not available. We could benefit from more information in cases where
<code class="literal">routeHandlers</code> cannot process a <code class="literal">Request</code> successfully.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_fourth_iteration"></a>3.4. Fourth Iteration</h2></div></div></div><p>In this iteration of code we would like to handle any exceptions
thrown from any of the <code class="literal">routeHandlers</code>. The full code for this
iteration is available at
<a class="ulink" href="https://github.com/gdevanla/scotty-from-ground-up/blob/master/app/Main4.hs" target="_top">Main4.hs</a>.</p><p>To get the error handling we need, we go back to our types and refine
them further. The new type definitions we will need in this iteration
are as follows</p><pre class="programlisting">type Response = String
type Request = String

-- new in this iteration
type ActionError = String
type ActionT = Exc.ExceptT ActionError Maybe Response
type Application = Request -&gt; ActionT

type Route = Application -&gt; Application

data AppState = AppState { routes:: [Route]}
type AppStateT = ST.State AppState</pre><p>Almost all types definitions you see above are carried over from the
previous iteration. The important changes are to the <code class="literal">Application</code>
type and by dependency to the <code class="literal">Route</code> type.</p><p>We define an <code class="literal">ActionError</code> type, that will hold an <code class="literal">exception</code>
string that the <code class="literal">routeHandlers</code> can create. Therefore, we need to
be able to wrap the <code class="literal">ActionError</code> along with the <code class="literal">Maybe Response</code>
value we expect from the <code class="literal">routeHandler</code> functions.</p><p>We reach out to the ExceptT monad for that. The ExceptT monad wraps
the <code class="literal">Either e a</code> in an outer monad. We pick this monad transformer,
since in the later sections we will see that we have a need to stack
more monads to get to what we want. Therefore, for this iteration each
<code class="literal">routeHandler</code> will either throw an exception which is captured in
<code class="literal">ActionError</code> or return a <code class="literal">Maybe</code> value which is captured in <code class="literal">Maybe
Response</code>. Note that we could have gotten away with an <code class="literal">Either e a</code>
monad for this iteration. The type could have been <code class="literal">Either ActionError
Request</code>. But, we skip that step and directly reach out to <code class="literal">ExcepT</code>
for reasons that become clearer later.</p><p>Now, we will see how we can handle these exceptions.  Similar to our
previous iterations, we will update all our <code class="literal">routeHandlers</code> to reflect
the new types. The <code class="literal">routeHandlerBuggy</code> will throw an exception whereas
all other <code class="literal">routeHandlers</code> successfully process requests. The new
listing of <code class="literal">routeHandlers</code> is shown below.</p><pre class="programlisting">constructResponse = unwords

routeHandler1 :: Request -&gt; ActionT
routeHandler1 request =
  Exc.ExceptT $ Just $ Right $ constructResponse [
  "request in handler1: got " ++ request]

routeHandler2 :: Request -&gt; ActionT
routeHandler2 input = Exc.ExceptT $ Just $ Right $ input ++ " middleware2 called\n"

routeHandlerBuggy :: Request -&gt; ActionT
routeHandlerBuggy input = throwError "Error from routeHandlerBuggy"

routeHandler3 :: String -&gt; ActionT
routeHandler3 request =
  Exc.ExceptT $ Just $ Right $ constructResponse [
  "request in handler3:" ++ request]

defaultRoute :: Request -&gt; ActionT
defaultRoute request =
  Exc.ExceptT $ Just $ Right $ constructResponse [
  request , "processed by defaultRoute"]</pre><p>In each of the <code class="literal">routeHandlers</code> we construct the response and then wrap
them into <code class="literal">Either</code> and then into a <code class="literal">Maybe</code> type. The wrapping of
<code class="literal">Maybe</code> at this point may not add much value, since a <code class="literal">Right</code> value
would indicate error anyways. But, as stated before the use of the
transformer becomes essential for the later steps.</p><p>Now with the knowledge of how we expect our client to provide the
<code class="literal">routerHandlers</code>,we turn our attention to the framework
functions. First, we provide a <code class="literal">errorHandler</code> function which will
be invoked from the <code class="literal">catch</code> block. This function will be called in
the event of any <code class="literal">exception</code> that is thrown from the <code class="literal">routeHandlers</code>.</p><pre class="programlisting">errorHandler :: Request -&gt; ActionT
errorHandler s = Exc.ExceptT $ Just $ Right $ "There was an error returned: " ++ s</pre><p>Then, we update our <code class="literal">route</code> function to <code class="literal">catch</code> exceptions. Note, that
we updated the call to <code class="literal">errorHandler</code> in third iteration. Instead of
checking for <code class="literal">Nothing</code> values before calling the <code class="literal">errorHandler</code> (in
third iteration), we call <code class="literal">cathcError</code> and provide the <code class="literal">errorHandler</code>
as the second argument to the <code class="literal">catchError</code>.  We abstract away this
into another function called <code class="literal">runAction</code>.</p><pre class="programlisting">route ::(Request -&gt; ActionT) -&gt; (String -&gt; Bool) -&gt; Route
route mw pat mw1 request =
  let tryNext = mw1 request in
  if pat request then
    runAction mw request
  else
    tryNext

runAction ::(Request -&gt; ActionT) -&gt; Request -&gt; Response
runAction mw request =
  let response = Exc.runExcept $ mw request `catchError` errorHandler
      left =  (\x -&gt; (++) "There was an error :" x)
      right = id
  in
    either left right response</pre><p>The <code class="literal">userInputLoop</code> function is also updated to reflect the types
change to the <code class="literal">route</code> function.</p><p>With these changes we are able to handle exceptions. If we type in
"buggy" for the request string while running Main4.hs, we will notice
that our request is handled by the <code class="literal">errorHandler</code> function.</p><p>By running <code class="literal">main4</code>, and providing <code class="literal">buggy</code> as input string, you notice
that the <code class="literal">errorHandler</code> is invoked.</p><pre class="programlisting">$ stack exec main4
Please type in the request
(one of 'handler1', 'handler2', 'handler3', 'buggy' or any string for
default handling)
buggy
There was an error returned: Error from routeHandlerBuggy</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_fifth_iteration"></a>3.5. Fifth Iteration</h2></div></div></div><p>One thing you will notice is that every <code class="literal">routeHandler</code> takes a
<code class="literal">String</code> as an argument. This argument will represent the <code class="literal">request</code>
information later on in the real <code class="literal">Scotty</code> library. A better way to
capture this information would be to wrap it in a type and make the value
available as input to a <code class="literal">Reader</code> monad. By wrapping in a new type
we let the <code class="literal">Scotty</code> framework process the low level message and
provide request arguments in different forms. In this section, we will
continue to assume that the request parameter is still a
<code class="literal">String</code>. But, we will make this value available through a <code class="literal">Reader</code>
monad. Replacing the <code class="literal">String</code> with some kind of newtype will be
straight forward later on.</p><p>The entire code for this section is available at
<a class="ulink" href="https://github.com/gdevanla/scotty-from-ground-up/blob/master/app/Main5.hs" target="_top">Main5.hs</a>.</p><p>The first thing we do in this iteartion is update the <code class="literal">ActionT</code> type.</p><pre class="programlisting">type ActionT = Exc.ExceptT ActionError (Reader Request) Response</pre><p>From the previous iteration, we replace <code class="literal">Either</code> to
<code class="literal">ExceptT</code>. <code class="literal">ExceptT</code> is a monad transformer that will help wrap the <code class="literal">Either</code>
type in a <code class="literal">Reader</code> monad. By, switching to <code class="literal">ExceptT</code> we are able to use the <code class="literal">Reader</code> that
will accept the <code class="literal">Request</code> value.</p><p>Next, we update our <code class="literal">client</code> functions the <code class="literal">routeHandlers</code> to return
the new <code class="literal">ActionT</code> type. Notice, that the signature of all the
<code class="literal">routerHandlers</code> change and they no more accept a <code class="literal">String</code> as an
argument. The <code class="literal">input</code> is retrieved with <code class="literal">ask</code>. Here, are the
definitions of the new <code class="literal">routerHandlers</code>.</p><pre class="programlisting">-- client functions
routeHandler1 :: ActionT
routeHandler1 = do
  input &lt;- ask
  return $ "middlware_func1 got input = " ++ input

routeHandler2 :: ActionT
routeHandler2 = do
  input &lt;- ask
  return $ "middlware_func2 got input = " ++ input

routeHandler3_buggy :: ActionT
routeHandler3_buggy = throwError "error from buggy handler"

routeHandler3 :: ActionT
routeHandler3 = do
  input &lt;- ask
  return $ "routeHandler3 called = " ++ input</pre><p>Notice that the only change we had to make to the <code class="literal">routerHandler</code> was
to switch its signature and <code class="literal">ask</code> for the <code class="literal">input</code> using the
<code class="literal">Reader</code> monad.</p><p>Next, we will look at the changes we need to make to the framework
functions. The change we have to do is to the <code class="literal">route</code> and <code class="literal">runAction</code>
functions. We have to unwrap the <code class="literal">ExceptT</code> monad stack which we will
do in the <code class="literal">runAction</code> function.</p><pre class="programlisting">route :: ActionT -&gt; (String -&gt; Bool) -&gt; Route
route mw pat mw1 input_string =
  let tryNext = mw1 input_string in
  if pat input_string
  then
    let x = runAction mw input_string
        y = fromMaybe "" x
    in
      y
  else
    tryNext

runAction ::
  Exc.ExceptT ActionError (Reader Request) Response
  -&gt; String -&gt; Maybe String
runAction action request =
  let response = flip runReader request
                 $ Exc.runExceptT
                 $ action `catchError` errorHandler
      left =  (\x -&gt; Just $ (++) "There was an error :" x)
      right = Just
  in
    either left right response</pre><p>The <code class="literal">runAction</code>  is called from <code class="literal">route</code> for the first matching
<code class="literal">route</code>. Notice, that we perform the following steps:</p><p>We run the <code class="literal">action</code> using <code class="literal">catchError</code> so that any exception raised by
the <code class="literal">routerHandlers</code> is processed by the <code class="literal">errorHandler</code>. To run the
<code class="literal">action</code> we first unwrap it using <code class="literal">runExceptT</code>. This gives us the
inner monad which is the <code class="literal">Reader</code>. Now we run the <code class="literal">Reader</code> monad, by
passing it the <code class="literal">request</code> string. Finally, the response is returned as
a <code class="literal">Right</code> value if the processing was successful or a <code class="literal">Left</code> value if
an error was raised. The <code class="literal">errorHandler</code> captures both the <code class="literal">input</code> and
the <code class="literal">error message</code> that was thrown by one of the route handlers.</p><pre class="programlisting">errorHandler :: String -&gt; ActionT
errorHandler error = do
  input &lt;- ask
  return $ "There was an error returned for input=" ++ input ++ ", error=" ++ error</pre><p>So, with that we are able to wrap our <code class="literal">ActionT</code> in a <code class="literal">Reader</code> as well
as still retain our <code class="literal">Either</code> monad to capture errors as well.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_sixth_iteration"></a>3.6. Sixth Iteration</h2></div></div></div><p>This will be our last iteration before we start looking at the real
thing. One last thing we want to do is change the type of our
<code class="literal">Response</code>. So far we have set the type of <code class="literal">Response</code> to be a
<code class="literal">String</code>. But, while building a framework, we want to be able to
create layers of middleware where the response can get updated by any
of these layers.  That also allows adding headers and other
information to the response before it is sent to the outside
world. Therefore, that will be the goal of this iteration.</p><p>The full source for this iteration can be found at
<a class="ulink" href="https://github.com/gdevanla/scotty-from-ground-up/blob/master/app/Main6.hs" target="_top">Main6.hs</a>.</p><p>As in the previous iteration, we first update our <code class="literal">ActionT</code> type.</p><pre class="programlisting">type ActionT a = Exc.ExceptT ActionError (ReaderT String (ST.State Response)) a</pre><p>In contrast to our type in previous interaction, we wrap the <code class="literal">Response</code>
in a <code class="literal">State</code> monad. And, since we also want to retain our <code class="literal">Reader</code>
monad, we update the <code class="literal">Reader</code> monad to <code class="literal">ReaderT</code> monad which helps us
stack the <code class="literal">Reader</code> and <code class="literal">State</code> monads. Everyone visualizes these
stacking in different ways, so there is no attempt made here to
describe it! The type of <code class="literal">ActionT</code> you see here is almost close to
what <code class="literal">Scotty</code> uses. So, it is helpful to review it and understand how
the monads are stacked up.</p><p>We now need to fix the  <code class="literal">runAction</code> from the previous iteration, to
take care of the change to <code class="literal">ActionT</code>. All we need to do here is add
<code class="literal">runState</code> to the unwrapping statements, since that is the only new
layer we  added. Everything else in <code class="literal">runAction</code> remains the same.</p><pre class="programlisting">runAction :: ActionT () -&gt; Request -&gt; Maybe Response
runAction action request =
  let (a, s) = flip ST.runState ""
               $ flip runReaderT request
               $ Exc.runExceptT
               $ action `catchError` errorHandler
      left = const $ Just "There was an error"
      right = const $ Just s in
    either left right a</pre><p>The changes we need to make to the <code class="literal">routerHandlers</code> are a bit
involved. Note, that we <code class="literal">ask</code> for the input string the same way we did
in our previous iterations. But, now we need to return a <code class="literal">State</code> monad
that accepts a <code class="literal">response</code> value as <code class="literal">state</code>. Since, the <code class="literal">State</code> monad
is tucked away three levels deep in a <code class="literal">Reader</code> and then in a <code class="literal">Either</code>
monad, we need to apply <code class="literal">lift</code> twice. (Note, that in the actual scotty
implementation, the <code class="literal">ActionT</code> is a new type and it is an instance of
various <code class="literal">Monad</code> classes. Which allows us to skip the explicit applying
of <code class="literal">lift</code> operation while using <code class="literal">Scotty</code> as the library). Here is the
list of the <code class="literal">routeHandlers</code> that go with this iteration.</p><pre class="programlisting">routeHandler1 :: ActionT ()
routeHandler1 = do
  input_string &lt;- ask
  let st =
        ST.modify
        (\_ -&gt; constructResponse ["request:" ++ input_string, "processed by routeHandler1"])
  lift . lift $ st

routeHandler2 :: ActionT ()
routeHandler2 = do
  input_string &lt;- ask
  lift . lift $ ST.modify  (\s -&gt; s ++ input_string ++ " inside middleware func 2")

routeHandler3_buggy :: ActionT ()
routeHandler3_buggy = throwError "error from buggy handler"

routeHandler3 :: ActionT ()
routeHandler3 = do
  input_string &lt;- ask
  lift . lift $ ST.modify (\s -&gt; s ++ input_string ++ " inside middleware func 3")</pre><p>With these changes, we have almost built the skeleton of the framework that
represents the data structures and implementation of <code class="literal">Scotty</code>.  With
this understanding, we are ready to go ahead and start studying how the
different parts of <code class="literal">Scotty</code> work together.</p><p>This chapter allowed us to build through a toy framework from very
basic types to some advanced uses of monads. Hopefully, you were able
to walk through this chapter and understand how we went about updating
our coding across different iterations. With this knowledge at hand,
it should be easier to look at the <code class="literal">Scotty</code> implementation in the
following chapter. Given that we were able to reason through the
different iterations, the same reasoning can be applied while we read
through the implementation.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_sample_web_application"></a>Chapter 4. Sample Web Application</h1></div></div></div><p>We start with a simple web application built using
Scotty. The application will have two end-points. One
end point will return a message formatted in HTML. The second
end point accepts a parameter in the form of a query-string
and embeds it into a dynamically generated HTML string and returns the
result.</p><pre class="programlisting">main :: IO ()
main = scotty 3000 $ do
  get "/" $ do
      html $ "Read you a Scotty!"
  get "/:username" $ do
    username &lt;- param "username"
    html $ mconcat [
         "&lt;h1&gt;Hello, ", username,  "&lt;/h1&gt;", "Hope you enjoy reading this book"]</pre><p>We will refer back to this example as we read through the
Scotty implementation. We will also update our example with more
features as we try to reason with some of the approaches taken in the
implementation of Scotty.</p><p>Let us look closely at this example. In the <code class="literal">main</code> function we call
<code class="literal">scotty</code> with two arguments. The first argument is the <code class="literal">port</code> number
on which we want the web application to listen on. The second argument
to <code class="literal">scotty</code> is a value of type <code class="literal">ScottyT Text IO</code>. We will look at this
type in detail later. But, for now it is enough to understand that this
wraps a <code class="literal">state</code> monad whose state contains the configuration of the
web application. The configuration would be the different HTTP
methods(<code class="literal">GET</code>, <code class="literal">POST</code>, etc.), the route patterns (<span class="emphasis"><em>/index</em></span>, <span class="emphasis"><em>/</em></span>, etc.)
the web application supports. Henceforth, we will refer to this
argument as <code class="literal">ScottyT</code> or more generally as <code class="literal">scotty state</code>.</p><p>The <code class="literal">scotty state</code> is built using functions like <code class="literal">get</code> <a href="#ftn.idm45784852398176" class="footnote" id="idm45784852398176"><sup class="footnote">[1]</sup></a>.
The first argument to <code class="literal">get</code> is a string which specifies the <code class="literal">url</code>
pattern. The second argument is the more interesting one. The
argument is of type <code class="literal">ActionT e m a</code>. The <code class="literal">ActionT e m a</code> is a monad
that stacks a few monads under it. Henceforth, we will refer to
this argument as the <code class="literal">action</code>. We will continue to use this term to
refer to this argument through this book. More specifically,
throughout this book, we will assume the application is instantiated
with default configuration. Therefore the <code class="literal">e</code> in <code class="literal">Action T</code> would be
a value of <code class="literal">ActionError</code> and <code class="literal">m</code> would be the <code class="literal">IO</code> monad. The <code class="literal">a</code> would vary
depending on the effect of the monad.</p><p>At the high level, here is what is happening. Each call to <code class="literal">get</code>
accepts an <code class="literal">url</code> pattern and an <code class="literal">action</code> that needs to be performed
if a client request matches the <code class="literal">url</code> pattern. Each call to <code class="literal">get</code> adds
a <code class="literal">route</code> to the <code class="literal">scotty state</code>. Therefore, a <code class="literal">route</code> contains the
<code class="literal">action</code> that has to be performed for a request made to a specific
<code class="literal">url</code> pattern. The <code class="literal">scotty state</code> contains the list of <code class="literal">routes</code>
that it can run every request through until one of the routes
successfully processes the request. In the sample application above we
add two routes to the <code class="literal">scotty state</code>. The first <code class="literal">route</code> contains the
action,</p><pre class="programlisting">do
      html $ "Read you a Scotty!"</pre><p>and the second route contains the <code class="literal">action</code></p><pre class="programlisting">$ do
    username &lt;- param "username"
    html $ mconcat [
         "&lt;h1&gt;Hello, ", username,  "&lt;/h1&gt;", "Hope you enjoy reading this book"]</pre><p>When the request arrives, either the <code class="literal">route</code> successfully executes (on
a match) by running the request through the <code class="literal">action</code> and returning a
<code class="literal">responses</code> or passes the <code class="literal">request</code> on to the next <code class="literal">route</code> on the
list.  For example, if our request url looked
"http://readyouascotty.com/", then "/" matches our request then the
<code class="literal">action</code> which returns "Read you a Scotty!" will be run. Or the next
<code class="literal">route</code> is checked and so on.</p><p>The concept is consistent with any web application one might have
created using other languages/frameworks. Our objective is to wrap
our head around how this whole process is handled in the
implementation. We want to understand what the <code class="literal">scotty state</code>
entails. We want to understand why we need <code class="literal">ActionT</code>. We will see how
the requests are threaded across different routes, parameters parsed
and errors handled. I hope this helps us identify patterns that we
could use in our own projects.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_entry_points_and_settings"></a>4.1. Entry Points and Settings</h2></div></div></div><p>The scotty app can be configured in a number of ways. All options can
be reviewed at
<a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty.hs#L55" target="_top">Scotty.hs</a>.</p><p>Some options available are as follows</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
scotty - This is the simplest. This function takes a port and the
  route handlers we will be looking at shortly
</li><li class="listitem">
scottyOpts - This function provides more options to run the
  scotty app. The <code class="literal">warp</code> server is the backend for <code class="literal">Scotty</code>.
</li><li class="listitem">
scottySocket - To run the Scotty app by listening to the warp server
  on an Unix socket.
</li><li class="listitem">
scottyApp - This is more to turn the application into another
  middleware of an WAI application which can be used by any handler. The
  <code class="literal">WAI</code> library can be viewed as the middleware siting between <code class="literal">Scotty</code>
  and the <code class="literal">warp</code> server.
</li></ul></div><p>These functions are wrappers around the functions in
<a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Trans.hs#L63" target="_top">Trans.hs</a>. We
will look at these functions in detail in later chapters.</p><p>Next, we will look at the data type that can be used to
configure the server.  As stated earlier, the scottyOpts function take
a value of <code class="literal">Options</code> record data type. The <code class="literal">Options</code> data type is declared in
<a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#L41" target="_top">Types.hs</a></p><p><strong>Options. </strong>
</p><pre class="programlisting">data Options = Options { verbose :: Int
                       , settings :: Settings }</pre><p>
</p><p>The <code class="literal">settings</code> attribute holds the warp server settings. The app
settings is an abstract data type that can be accessed through the
provided default constructor and a group of setter methods as defined
under
<a class="ulink" href="https://hackage.haskell.org/package/warp-3.2.11/docs/Network-Wai-Handler-Warp.html#v:defaultSettings" target="_top">warp
settings</a></p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm45784852398176" class="footnote"><p><a href="#idm45784852398176" class="simpara"><sup class="simpara">[1] </sup></a>other
functions would be <code class="literal">post</code>, <code class="literal">put</code>, <code class="literal">delete</code> etc. Refer to
(<a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty.hs#L238)" target="_top"><code class="literal">Scotty.hs</code>)</a></p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="routes"></a>Chapter 5. Declaring routes</h1></div></div></div><p>From the sample web application, we see that the third parameter to
the <code class="literal">scotty</code> function is a list of actions that needs to be performed
if the request matches the route pattern specified as the second
argument. Every time a request needs to be processed, we want to be
able to match the request to the <code class="literal">url</code> pattern and use the respective
<code class="literal">action</code> to process the request. Therefore, we want want to wrap each
action in a <code class="literal">route</code>. Hence we create a set of routes to handle request to
different <code class="literal">url</code> patterns. We will store this information in the
<code class="literal">scotty state</code>.</p><p>We want any client of Scotty to be able to create a route handler for each
route pattern. One way we can do that is to thread the request through
a list of routes handlers until one of the routes wraps an action that
succeeds. Every route handler should take a <code class="literal">Request</code> type and return some <code class="literal">m
Response</code> type (eg. IO Response). We also want to thread our requests to the next
route handler. Therefore, we a need to create a  <code class="literal">route</code> value whose
type would be to process a <code class="literal">request</code> using a particular <code class="literal">action</code>
and also accept another <code class="literal">route</code> handler that can be used if the <code class="literal">request</code>
cannot be processed with the given action.</p><p>Therefore, we would end up with a type that looks conceptually
as follows. Notice, that return value is still of type <code class="literal">Response</code>.</p><pre class="programlisting">Request -&gt; (Request -&gt; Response) -&gt; Response</pre><p>This is exactly the kind of type we built upon in the toy <code class="literal">Scotty</code>
framework we built.</p><p>Let us now walk through some of the real types that help us build these
states.</p><p><strong><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#L54" target="_top">Application and Middleware</a>. </strong>
</p><pre class="programlisting">----- Transformer Aware Applications/Middleware -----
type Middleware m = Application m -&gt; Application m
type Application m = Request -&gt; m Response</pre><p>
</p><p>These two types hide the <code class="literal">Application</code> and <code class="literal">Middleware</code> types from
<code class="literal">Network.Wai</code>. <code class="literal">Network.Wai</code> is the backend interface to a library
like <code class="literal">warp</code>. The <code class="literal">Application</code> type is self-explanatory. It is a
function takes a <code class="literal">Request</code> and returns a <code class="literal">Response</code> wrapped in some
monad <code class="literal">m</code>. The default <code class="literal">Application</code> type provided by <code class="literal">Network.Wai</code>
has this type,</p><pre class="programlisting">type Application = Request -&gt; (Response -&gt; IO ResponseReceived) -&gt; IO ResponseReceived</pre><p>The reason why Scotty abstracts over this type will become clearer
later on. For now, it is sufficient to understand that with the local
<code class="literal">Application</code> type Scotty can wrap the <code class="literal">Response</code> in a stack of monads
that will abstract away some of the error handling that would be
required. Notice, this <code class="literal">Application</code> type differs from our toy
example. This is due some redirection introduced by <code class="literal">Network.Wai</code>
library to control the <code class="literal">ResponseReceived</code> values returned by each <code class="literal">Application</code>.</p><p>Scotty also declares a <code class="literal">Middleware</code> type. This type is an example of
continuation-passing style where a value of type <code class="literal">Middleware</code> takes an
<code class="literal">Application</code> and then decides to delegate the call to its second
parameter which happens to be another <code class="literal">Application</code>. Using, this
pattern we can thread a request through different <code class="literal">Application</code> values
until the request in successfully processed. This type also gives
Scotty the ability to thread a request through a pipeline of
<code class="literal">Middleware</code> values. The <code class="literal">route</code> value we were looking for in the
earlier will be a example of <code class="literal">Middleware</code> value. With the initial
setup of our sample application, we end up with a list of routes which
are of type <code class="literal">[Middleware m]</code>. Note, that this type aligns with the
type the <code class="literal">route</code> function in the toy example was using.</p><p>Let us now see how the above two types are used.</p><p><strong><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#58" target="_top">Types.hs</a>. </strong>
</p><pre class="programlisting">--------------- Scotty Applications -----------------
data ScottyState e m =
    ScottyState { middlewares :: [Wai.Middleware]
                , routes :: [Middleware m]
                , handler :: ErrorHandler e m
                }</pre><p>
</p><p>In this chapter we will focus on the <code class="literal">routes</code> attribute. The routes
attribute is a list of routes that Scotty needs to thread every
request through till the request is successfully processed. As we
discussed earlier, another way to look at the type of one element of
<code class="literal">routes</code> would be</p><pre class="programlisting">route:: Middleware m

route:: Application m -&gt; Application m

route ::  (Request -&gt; m Response) -&gt; (Request -&gt; m Response)

route ::  (Request -&gt; m Response) -&gt; Request -&gt; m Response</pre><p>So, we see that an element of <code class="literal">routes</code> is a type that take a function
that turns a <code class="literal">Request</code> into <code class="literal">m Response</code>. In the process, it also
receives another function as a continuation that can be used if the
first function argument cannot process the request successfully. The
tricky thing to observe for a some of us would be to see that the
final return value of this function in still <code class="literal">m Response</code>, even
though the above organization makes it look like a <code class="literal">Middleware</code>
value is returned. We specifically state the return value of this
function is <code class="literal">m Response</code>, since that is what is required to interact
with the <code class="literal">Network.Wai</code> layer.</p><p>How does Scotty configure these routes? Lets take a look at a
<code class="literal">Hello, Scotty</code> app.  The third parameter to the <code class="literal">scotty</code> function is a
monad. More specifically, it is a State monad of type</p><p><strong><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#74" target="_top">ScottyT</a>. </strong>
</p><pre class="programlisting">newtype ScottyT e m a = ScottyT { runS :: State (ScottyState e m) a }
    deriving ( Functor, Applicative, Monad )</pre><p>
</p><p>Scotty uses this state monad to register the list of actions, where
each action is wrapped in one route. For example every action listed
in the third argument to <code class="literal">scotty</code> function returns a <code class="literal">ScottyT
e m a</code> and the state monad captures all the actions in its
state.</p><p>Let us take a look at how this is done.</p><pre class="programlisting">  get "/:word" $ do
          beam &lt;- param "word"
                  html $ mconcat ["&lt;h1&gt;Scotty, ", beam, " me up!&lt;/h1&gt;"]</pre><p>The <code class="literal">get</code> function resolves to <code class="literal">addroute GET</code> function in</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Route.hs#30" target="_top">get</a></p><pre class="programlisting">-- | get = 'addroute' 'GET'
get :: (ScottyError e, MonadIO m) =&gt; RoutePattern -&gt; ActionT e m () -&gt; ScottyT e m ()
get = addroute GET</pre><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Route.hs#67" target="_top">addroute</a></p><pre class="programlisting">-- | Define a route with a 'StdMethod', 'T.Text' value representing the path spec,
-- and a body ('Action') which modifies the response.
--
-- &gt; addroute GET "/" $ text "beam me up!"
--
-- The path spec can include values starting with a colon, which are interpreted
-- as /captures/. These are named wildcards that can be looked up with 'param'.
--
-- &gt; addroute GET "/foo/:bar" $ do
-- &gt;     v &lt;- param "bar"
-- &gt;     text v
--
-- &gt;&gt;&gt; curl http://localhost:3000/foo/something
-- something
addroute :: (ScottyError e, MonadIO m) =&gt; StdMethod -&gt; RoutePattern -&gt; ActionT e m () -&gt; ScottyT e m ()
addroute method pat action = ScottyT $ MS.modify $ \s -&gt; addRoute (route (handler s) (Just method) pat action) s</pre><p>The core function to understand is the <code class="literal">addRoute</code> function. The
function takes a <code class="literal">StdMethod</code> which specifies one of the Http
request methods. The second parameter is the route pattern. For
example "/index" or "/:name" etc. The third parameter is the action
that is going to be performed for the given request. Notice that each
each action is wrapped inside a route closure. This is the parameter that is
provided as the second parameter to <code class="literal">get</code> as an <code class="literal">action</code> value.</p><p>Lets look closely at the <code class="literal">addroute</code> function. It returns <code class="literal">ScottyT</code>
object which is the state monad that wraps the <code class="literal">ScottyState</code>. The
computation is the state monad is just weaving the state through
<code class="literal">modify</code>. <code class="literal">modify</code> accepts a function whose first argument accepts a <code class="literal">state</code> and
returns a modified <code class="literal">state</code>. So, what is this function doing?</p><p>The function provided to <code class="literal">modify</code>, adds a route to the
ScottyState.routes attributes. Recollect, that the each route is of
type <code class="literal">Middleware m</code>. That is, it takes a (Request → m Response) and a
fallback (Request → m Response). The <code class="literal">route</code> function creates the
request <code class="literal">Middleware m</code> that gets added as a <code class="literal">route</code> to <code class="literal">ScottyState</code>.</p><p>We will look at the <code class="literal">route</code> function in detail later on. But for now
it is enough to understand that the <code class="literal">route</code> function wraps the <code class="literal">action</code>
that needs to be performed for the request. For the novice haskeller,
this a great example of power of currying. We seamlessly, create a
<code class="literal">route</code> value, by providing just the first 4 parameters. The only
remaining parameter to this function is <code class="literal">Middleware m</code>. When this
function gets called later, the <code class="literal">Application</code> (which happens to be the
next <code class="literal">route</code> in the list of <code class="literal">routes</code> and the <code class="literal">Request</code> object are
provided. Therefore, the types check out.  Take a minute and reason
how the <code class="literal">addRoute</code> function returns a value of type <code class="literal">Middleware m</code>
when called inside the <code class="literal">State</code> monad. Then think about how a <code class="literal">Request</code>
and <code class="literal">Application m</code> can be passed to this function at a later time.</p><p><strong><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Route.hs#67" target="_top">route</a>. </strong>
</p><pre class="programlisting">route :: (ScottyError e, MonadIO m) =&gt; ErrorHandler e m -&gt; Maybe StdMethod -&gt; RoutePattern -&gt; ActionT e m () -&gt; Middleware m
route h method pat action app req =
    let tryNext = app req
        {- |
          We match all methods in the case where 'method' is 'Nothing'.
          See https://github.com/scotty-web/scotty/issues/196
        -}
        methodMatches :: Bool
        methodMatches =
            case method of
                Nothing -&gt; True
                Just m -&gt; Right m == parseMethod (requestMethod req)
    in if methodMatches
       then case matchRoute pat req of
            Just captures -&gt; do
                env &lt;- mkEnv req captures
                res &lt;- runAction h env action
                maybe tryNext return res
            Nothing -&gt; tryNext
       else tryNext</pre><p>
</p><p>Now, looking closely, when the <code class="literal">route</code> gets added to the list of
<code class="literal">routes</code>, the parameters provided to this function are <code class="literal">ErrorHandler e
m</code>, <code class="literal">Maybe StdMethod</code>, <code class="literal">RouterPattern</code>, <code class="literal">ActionT e m</code>. The remaining
parameters are provided when the client requests arrive. When the
client requests arrive, first the <code class="literal">ActionT e m ()</code> value is run using
<code class="literal">runAction</code> and if that action fails, then <code class="literal">tryNext</code> is called which
passes the <code class="literal">Request</code> on to the next <code class="literal">Application</code>. The next handler
could be any <code class="literal">Middleware m</code> (that is another <code class="literal">route</code> or an arbitrary
middlware).</p><p>One way to understood the type of this function, is to flatten it out
as follows</p><p><strong>Resolving the types of <code class="literal">route</code>. </strong>
</p><pre class="programlisting">route :: (ScottyError e, MonadIO m) =&gt; ErrorHandler e m -&gt; Maybe
StdMethod -&gt; RoutePattern -&gt; ActionT e m () -&gt; Middleware m

route :: (ScottyError e, MonadIO m) =&gt; ErrorHandler e m -&gt; Maybe
StdMethod -&gt; RoutePattern -&gt; ActionT e m () -&gt; (Application m -&gt;
Application m).

route :: (ScottyError e, MonadIO m) =&gt; ErrorHandler e m -&gt; Maybe
StdMethod -&gt; RoutePattern -&gt; ActionT e m () -&gt; (Request -&gt;  m Response) -&gt;
(Request -&gt; m Response)</pre><p>
</p><p>Therefore, using the flattened type signature, we see that</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
When <code class="literal">route</code> is added to the <code class="literal">routes</code> attribute, we add a
           curried function of type <code class="literal">(Request -&gt; m Response -&gt; Request -&gt; m
           Response)</code>.
</li><li class="listitem">
When the request actually has to be processed, the curried function
           is then invoked with the next <code class="literal">route</code> in the list that happens to be
           of type <code class="literal">Middleware</code>. But, when all <code class="literal">middlewares</code> are applied, the
           final type resolves to type <code class="literal">Request -&gt; m Response</code>.
</li><li class="listitem">
Now the function is applied to a <code class="literal">Request</code>
           value. The <code class="literal">runAction</code> on the request either succeeds or on
           failure, the <code class="literal">Request</code> is passed on to next <code class="literal">Application
           m</code>.
</li></ol></div><p>In this section, we explored how the third parameter we passed to
<code class="literal">scotty</code> function is used to configure a list of routes, which each
route captures the <code class="literal">url</code> pattern of the requests it can service and
the <code class="literal">action</code> that needs to be applied to the requests when the <code class="literal">url</code>
pattern matches. This also aligns with toy scotty we built using a
similar <code class="literal">route</code> function.</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_initializing_the_app"></a>Chapter 6. Initializing the App</h1></div></div></div><p>In the previous chapter, we looked at how the routes get built when the entry
point of our app is called.</p><p>So far, all the statements under <code class="literal">do [expression]</code> which was the third
parameter to the <code class="literal">scotty</code> function has been evaluated and all routes
added to the state of the <code class="literal">ScottyT e m a</code>. For our purpose, this type
resolved to <code class="literal">ScottyT e IO ()</code>. The <code class="literal">e</code> is for error-handling and we
will take a look at it later.</p><p>If you are interested in the call trace so far, here it is</p><p>Scotty.scotty → Trans.scottyT → Trans.scottyOpsT.</p><p>Now, let us take a look at scottyOpsT where our web application starts
listening and serving requests.</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Trans.hs#L70" target="_top">ScottyOpsT</a></p><pre class="programlisting">-- | Run a scotty application using the warp server, passing extra options.
-- NB: scottyOpts opts === scottyOptsT op
scotidtyOptsT :: (Monad m, MonadIO n)
            =&gt; Options
            -&gt; (m Response -&gt; IO Response) -- ^ Run monad 'm' into 'IO', called at each action.
            -&gt; ScottyT e m ()
            -&gt; n ()
scottyOptsT opts runActionToIO s = do
      when (verbose opts &gt; 0) $
              liftIO $ putStrLn $ "Setting phasers to stun... (port " ++ show (getPort (settings opts)) ++ ") (ctrl-c to quit)"
    liftIO . runSettings (settings opts) =&lt;&lt; scottyAppT runActionToIO s</pre><p>The <code class="literal">runSettings</code> function is from <code class="literal">Network.Wai.Handler.Warp</code>. Its
type is</p><p><a class="ulink" href="https://hackage.haskell.org/package/warp-3.2.11.1/docs/src/Network-Wai-Handler-Warp-Run.html#runSettings" target="_top">runSettings</a></p><pre class="programlisting">runSettings :: Settings -&gt; Application -&gt; IO ()</pre><p>The <code class="literal">(settings opts)</code> returns the <code class="literal">Settings</code> value. We looked at the
the <code class="literal">Options</code> record type in <code class="literal">Types.hs</code> earlier.</p><p><code class="literal">runSettings</code> is first called with <code class="literal">settings</code>. The second parameter to
<code class="literal">runSettings</code> is</p><p><a class="ulink" href="http://hackage.haskell.org/package/wai-3.2.1.1/docs/Network-Wai.html#t:Application" target="_top">Network.Wai.Application</a></p><pre class="programlisting">type Application = Request -&gt; (Response -&gt; IO ResponseReceived) -&gt; IO ResponseReceived</pre><p>We build this value using <code class="literal">scottyAppT runActionIO s</code>. The
<code class="literal">runActionIO</code> is set to <code class="literal">id</code> and <code class="literal">s</code> is the value of <code class="literal">ScottyT e m ()</code>
which is the state of the web application.  Now, we turn our attention
to <code class="literal">scottyAppT</code> tht will produce the `Application value needed.</p><pre class="programlisting">-- | Turn a scotty application into a WAI 'Application', which can be
-- run with any WAI handler.
-- NB: scottyApp === scottyAppT id
scottyAppT :: (Monad m, Monad n)
           =&gt; (m Response -&gt; IO Response) -- ^ Run monad 'm' into 'IO', called at each action.
           -&gt; ScottyT e m ()
           -&gt; n Application
scottyAppT runActionToIO defs = do
    let s = execState (runS defs) def
    let rapp req callback = runActionToIO (foldl (flip ($)) notFoundApp (routes s) req) &gt;&gt;= callback
    return $ foldl (flip ($)) rapp (middlewares s)</pre><p>As a first step, we <code class="literal">execState</code> of <code class="literal">ScottyT e m()</code>. This creates all
the <code class="literal">routes</code> that were declared in our app. Recollect, the <code class="literal">execState</code>
invokes the state monad <code class="literal">ScottyT e m()</code> that was returned by
consecutive calls to <code class="literal">addroute</code> as each of our <code class="literal">do &lt;expressions&gt;</code> were
evaluated. This statement evaluates the <code class="literal">route</code> function we looked at
in the previous chapter.</p><pre class="programlisting">let s = execState (runS defs) def</pre><p>Now we need to return a function that ultimately takes a
<code class="literal">Request</code> and returns a <code class="literal">m Response</code>. In other words it is the
<code class="literal">Application m</code> type we have in <code class="literal">Types.hs</code>.</p><p>There are a couple of things we need to have. We want to thread
a <code class="literal">Request</code> through all the <code class="literal">routes. Once one of the `routes</code> returns
a <code class="literal">IO Response</code>, we will have to apply all middlewares in the same
order they appear in the list.  Therefore, we do two things, we
defined a function <code class="literal">rapp</code> which is of the following type</p><pre class="programlisting">rapp:: Request -&gt; (Response -&gt; IO ResponseRecieved)
rapp req callback = ...</pre><p>When we fold over all the user defined routes and middleware we want something like</p><pre class="programlisting">M1 $ ( M2 $ ...Mn ($ ( rapp )</pre><p>And then <code class="literal">rapp</code> expands to</p><pre class="programlisting">M1 $ ( M2 $ ...Mn ($ ( R1 -&gt; R2 -&gt; ....-&gt; notFoundApp))</pre><p>where R1, R2, ..Rn are the list of routes of type
Middleware m.  And since <code class="literal">rapp</code> takes two other parameters, the
returned type from scottyAppT is a function that takes the  <code class="literal">Request</code> and
returns <code class="literal">Response m</code>. And since we run this whole function in a IO
Monad in our case, we get back</p><pre class="programlisting">IO (Request -&gt; IO Response)
-- which can also be written asciidoc
IO (Application)

-- and replacing with generic monad, we have
n Application</pre><p>Now, going back to <code class="literal">scottyOptsT</code>, where we had a call to <code class="literal">scottyAppT</code>, we
apply <code class="literal">runSettings (settings opts)</code> to the its return value <code class="literal">IO Application</code>.</p><p>Therefore, using <code class="literal">scottyOptsT</code> we were able to initialize the <code class="literal">Network.Wai</code> interface
to start listening to user requests.</p><p>The core of the initialization happens in the <code class="literal">scottyAppT</code> or one of
its variants in the <code class="literal">Scotty</code> library.</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_handling_requests"></a>Chapter 7. Handling requests</h1></div></div></div><p>So far we have seen how we set up the state of a <code class="literal">Scotty</code> app and then also
studied how the <code class="literal">web app</code> is started before it starts serving requests.</p><p>One important thing to recollect that we learned during this process
was the <code class="literal">Scotty</code> state updates itself with the list of routes as
defined in the declaration of the web app. Each of the routes that are
defined is a function that contains the <code class="literal">action</code> that needs to be
performed once the incoming <code class="literal">Request</code> for  a route matches the
pre-defined routes.</p><p>There are 2 important functions that handles this process. We already
saw one function in the chapter on <a class="link" href="#routes" title="Chapter 5. Declaring routes">routes</a> where we briefly
talked about <code class="literal">route</code> function. This was the function that captured
the <code class="literal">action</code> that was provided for each <code class="literal">route</code>. The second function
we will discuss will be <code class="literal">runAction</code>.</p><p>Let’s take a look at each of these functions.</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Route.hs#L67" target="_top">Routes.hs</a></p><pre class="programlisting">route :: (ScottyError e, MonadIO m) =&gt; ErrorHandler e m -&gt; Maybe StdMethod -&gt; RoutePattern -&gt; ActionT e m () -&gt; Middleware m
route h method pat action app req =
    let tryNext = app req
        methodMatches :: Bool
        methodMatches =
            case method of
                Nothing -&gt; True
                Just m -&gt; Right m == parseMethod (requestMethod req)
    in if methodMatches
       then case matchRoute pat req of
            Just captures -&gt; do
                env &lt;- mkEnv req captures
                res &lt;- runAction h env action
                maybe tryNext return res
            Nothing -&gt; tryNext
       else tryNext</pre><p>The <code class="literal">route</code> function is called during the setting up of <code class="literal">routes</code>
attribute of <code class="literal">ScottyState</code> data type. This function is called for each
route that is declared in our web application. The function is initially
called with an <code class="literal">ErrorHandler e m</code> (attribute of ScottyState), the
<code class="literal">StdMethod</code> value (the request type <code class="literal">GET</code>, <code class="literal">POST</code> etc), the
<code class="literal">RoutePattern</code> (the patterns like <span class="emphasis"><em>/index</em></span>), and the <code class="literal">action</code> of type
<code class="literal">ActionT e m()</code>. We will look that <code class="literal">ActionT e m ()</code> when we discuss
<code class="literal">runAction</code>.  Once, these three arguments are applied, we have a
function type <code class="literal">Middleware m</code>.</p><p>This is the function that will be called while processing each
request as we look through each route to satisfy a request. In other
words, the list of these functions form the list of <code class="literal">routes</code> or list
of <code class="literal">Middleware m</code>.</p><p>The <code class="literal">route</code> function, when called checks if the request method and
route pattern match what the given action can process. On a match, first the the
<code class="literal">Request</code> value <code class="literal">req</code> is parsed using <code class="literal">mkEnv</code> into the <code class="literal">ActionEnv</code>
type.</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#L109" target="_top">ActionEnv</a></p><pre class="programlisting">data ActionEnv = Env { getReq       :: Request
                     , getParams    :: [Param]
                     , getBody      :: IO ByteString
                     , getBodyChunk :: IO BS.ByteString
                     , getFiles     :: [File]
                     }</pre><p>Recollect, that the function type of <code class="literal">route</code> function at this point is
<code class="literal">Middleware m</code>. That is</p><pre class="programlisting">Application m -&gt; Application m
-- that expands out to
Application m -&gt; Request -&gt; m Response</pre><p>Once, we have the request parsed, we run the request through the
<code class="literal">ActionT e m()</code>. If running the <code class="literal">ActionT e m</code> succeeds, we return, or
else we pass the request on to the next <code class="literal">Application m</code>. This
continues until the request can be satisfied or until the <code class="literal">notFound</code>
value is found. Note that the <code class="literal">notFound</code> value is the last
<code class="literal">Application</code> value attached in the <code class="literal">scottyAppT `. That allows the
`types</code> to check out and finally have a function that takes a
<code class="literal">Request</code> and returns a <code class="literal">m Response</code>.</p><p>We will shortly turn our attention to 'runAction` function. Before, that we
will look closely at <code class="literal">ActionT e m ()</code></p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#L138" target="_top">ActionT
e m a</a></p><pre class="programlisting">newtype ActionT e m a = ActionT { runAM :: ExceptT (ActionError e) (ReaderT ActionEnv (StateT ScottyResponse m)) a }
            deriving ( Functor, Applicative, MonadIO )</pre><p>Let us unwrap this transformer stack. Refering back to the toy
application may help at this point! The <code class="literal">ScottyResponse</code> type</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#L126" target="_top">ScottyResponse</a></p><pre class="programlisting">data ScottyResponse = SR { srStatus  :: Status
                         , srHeaders :: ResponseHeaders
                         , srContent :: Content
                         }</pre><p>This type packs the response that is delivered across the <code class="literal">Middleware
m</code> values as the request is processed by each middleware. This is
similar to the simpler <code class="literal">Response</code> type we had in out toy application.</p><p>The <code class="literal">a</code> usually will be <code class="literal">()</code> since each <code class="literal">action</code> updates the <code class="literal">state</code>
which is the <code class="literal">ScottyResponse</code>. This is discussed in the next chapter.</p><p>The <code class="literal">StateT</code> object is run inside <code class="literal">ReaderT</code> and the <code class="literal">Reader</code> monad
makes the <code class="literal">ActionEnv</code> value available to the <code class="literal">action</code>. In our web
application, we use the <code class="literal">param</code> function to access the parameters that
are submitted along with the request. The <code class="literal">param</code> function wraps the
<code class="literal">ask</code> functions of the <code class="literal">Reader</code> monad. We will explore the code that
parses the params seperately. <code class="literal">ExceptT</code> wraps the action and also a
error value <code class="literal">ActionError e</code> if the processing of the response fails.</p><p>The use of this value is best understood by its use in the <code class="literal">runAction</code> function.</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#L138" target="_top">Action
T e m a</a></p><pre class="programlisting">newtype ActionT e m a = ActionT { runAM :: ExceptT (ActionError e) (ReaderT ActionEnv (StateT ScottyResponse m)) a }
    deriving ( Functor, Applicative, MonadIO )</pre><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Action.hs#L63" target="_top">runAction</a></p><pre class="programlisting">-- Nothing indicates route failed (due to Next) and pattern matching should continue.
-- Just indicates a successful response.
runAction :: (ScottyError e, Monad m) =&gt; ErrorHandler e m -&gt; ActionEnv -&gt; ActionT e m () -&gt; m (Maybe Response)
runAction h env action = do
    (e,r) &lt;- flip MS.runStateT def
           $ flip runReaderT env
           $ runExceptT
           $ runAM
           $ action `catchError` (defH h)
    return $ either (const Nothing) (const $ Just $ mkResponse r) e</pre><p>The <code class="literal">runAction</code> is where all the unpacking is happening. The
<code class="literal">catchError</code> function runs the <code class="literal">ActionT e m a</code> monad if that raises an
error, then handles the error using the <code class="literal">defH h</code> handler. The <code class="literal">defH h</code>
handler handles exception.</p><p>Now, lets look at how the <code class="literal">action</code> is run.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
runAM returns ExceptT
</li><li class="listitem">
runExceptT returns the ReaderT
</li><li class="listitem">
Since, runReaderT takes the reader and then the environment,
     we apply <code class="literal">flip</code> to runReaderT. This way we can apply the <code class="literal">env</code>
     and then provide the actual <code class="literal">Reader</code> monad as a parameter.
</li><li class="listitem">
Similarly, we unwrap the <code class="literal">StateT</code> , apply <code class="literal">flip</code> so that we
     can apply the function to <code class="literal">def</code> before we apply the
     function to wrapped state.
</li><li class="listitem">
This computation returns (e, r., where e is a <code class="literal">Maybe</code> type and
     <code class="literal">r</code> is the state that holds the response that is created so far.
</li><li class="listitem">
<code class="literal">either</code> return <code class="literal">Maybe</code> value of the <code class="literal">Response</code>.
</li></ol></div><p>What this means is, the <code class="literal">Request</code> parameters are available in
<code class="literal">env</code>. Therefore, using the <code class="literal">params</code> function we can access those
values. Also, in our sample app, the action returns a modified
<code class="literal">Response</code>. That is the <code class="literal">state</code> in <code class="literal">ScottyResponse</code> is updated in each
<code class="literal">action</code>. In summary, any function whose type as ActionT e m a, has
access to <code class="literal">Reader</code> monad related functions to <code class="literal">ask</code> for request params and also also
has access to <code class="literal">State</code> monad related functions like <code class="literal">modify</code> to update
the <code class="literal">Response</code>.</p><p>This actual accessing of <code class="literal">Request</code> and update of <code class="literal">Response</code> will
discussed in the later chapters. It could be useful to refer back
to this section while reading about how parameters are handled and how
the response is updated.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_acessing_request_parameters"></a>7.1. Acessing Request Parameters</h2></div></div></div><p>Let us start with an example that uses the query parameters that is
passed along with the request</p><pre class="programlisting">get "/:username" $ do
    username &lt;- param "username"
    --  use username in the action</pre><p>As we have seen earlier, the third parameter to the <code class="literal">get</code> function
is the <code class="literal">ActionT e m a</code> value. Therefore, <code class="literal">param</code> also returns a
<code class="literal">ActionT e m a</code> values, where <code class="literal">a</code> will either be the value of
<code class="literal">username</code> passed in the request if the parameter is found or it might return an error.</p><p>In this section we will study how the request parameters are parsed in
Scotty. Recall, that in <code class="literal">route</code> function, we have a call to
<code class="literal">mkEnv</code>. This function captures all the information about the
<code class="literal">request</code> into the <code class="literal">ActionEnv</code> record.</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Internal/Types.hs#L109" target="_top">ActionEnv</a></p><pre class="programlisting">data ActionEnv = Env { getReq       :: Request
                     , getParams    :: [Param]
                     , getBody      :: IO ByteString
                     , getBodyChunk :: IO BS.ByteString
                     , getFiles     :: [File]
                     }</pre><p>The <code class="literal">getParams</code> attribute of this record type captures all the request
params.</p><p>The two functions used to lookup parameters are defined as follows:</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Action.hs#L181" target="_top">param</a></p><pre class="programlisting">param :: (Parsable a, ScottyError e, Monad m) =&gt; T.Text -&gt; ActionT e m a
param k = do
    val &lt;- ActionT $ liftM (lookup k . getParams) ask
    case val of
        Nothing -&gt; raise $ stringError $ "Param: " ++ T.unpack k ++ " not found!"
        Just v  -&gt; either (const next) return $ parseParam v</pre><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Action.hs#L195" target="_top">params</a></p><pre class="programlisting">-- | Get all parameters from capture, form and query (in that order).
params :: Monad m =&gt; ActionT e m [Param]
params = ActionT $ liftM getParams ask</pre><p>Recollect, <code class="literal">ActionT</code> wraps the <code class="literal">ReaderT</code> monad. Therefore, the
<code class="literal">ActionEnv</code> values is passed in as the environment. <code class="literal">ask</code> returns
<code class="literal">ActionEnv</code> and then <code class="literal">getParams</code> returns <code class="literal">[Params]</code>. We <code class="literal">liftM</code>
getParams since <code class="literal">ask</code> is <code class="literal">Reader m a</code>. We put the value back into
<code class="literal">ActionT</code> before returning. All parameters are parsed using the `
parseParams` method of the <code class="literal">Parseable</code> type class.</p><p>Other functions defined in <code class="literal">Action.hs</code> that can be used to access
<code class="literal">Request</code> are as follows:</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Action.hs#L143" target="_top">Functions
to access Request</a></p><pre class="programlisting">-- | Get the 'Request' object.
request :: Monad m =&gt; ActionT e m Request
request = ActionT $ liftM getReq ask

-- | Get list of uploaded files.
files :: Monad m =&gt; ActionT e m [File]
files = ActionT $ liftM getFiles ask

-- | Get a request header. Header name is case-insensitive.
header :: (ScottyError e, Monad m) =&gt; T.Text -&gt; ActionT e m (Maybe T.Text)
header k = do
    hs &lt;- liftM requestHeaders request
    return $ fmap strictByteStringToLazyText $ lookup (CI.mk (lazyTextToStrictByteString k)) hs

-- | Get all the request headers. Header names are case-insensitive.
headers :: (ScottyError e, Monad m) =&gt; ActionT e m [(T.Text, T.Text)]
headers = do
    hs &lt;- liftM requestHeaders request
    return [ ( strictByteStringToLazyText (CI.original k)
             , strictByteStringToLazyText v)
           | (k,v) &lt;- hs ]

-- | Get the request body.
body :: (ScottyError e,  MonadIO m) =&gt; ActionT e m BL.ByteString
body = ActionT ask &gt;&gt;= (liftIO . getBody)

-- | Get an IO action that reads body chunks
--
-- * This is incompatible with 'body' since 'body' consumes all chunks.
bodyReader :: Monad m =&gt; ActionT e m (IO B.ByteString)
bodyReader = ActionT $ getBodyChunk `liftM` ask

-- | Parse the request body as a JSON object and return it. Raises an exception if parse is unsuccessful.
jsonData :: (A.FromJSON a, ScottyError e, MonadIO m) =&gt; ActionT e m a
jsonData = do
    b &lt;- body
    either (\e -&gt; raise $ stringError $ "jsonData - no parse: " ++ e ++ ". Data was:" ++ BL.unpack b) return $ A.eitherDecode b</pre><p>All the above listed functions work on the <code class="literal">ActionEnv</code> value mentioned
earlier. The <code class="literal">mkEnv</code> function is responsible for creating this value
from the raw request data. We do not discuss the details of this
function in this book. But, if you are interested in understanding the
lower level details of how the <code class="literal">Request</code> object is parsed into the
<code class="literal">ActionEnv</code> value, then this function is where you should start.</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Action.hs#L144" target="_top">mkEnv</a></p><pre class="programlisting">mkEnv :: forall m. MonadIO m =&gt; Request -&gt; [Param] -&gt; m ActionEnv</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_response"></a>Chapter 8. Response</h1></div></div></div><p>Finally, we look at how the responses are created. If you have
followed along than you have would have noticed that the <code class="literal">ActionT</code>
values holds the <code class="literal">Response</code> in its <code class="literal">state</code>. The response is created
during the call to <code class="literal">runAction</code> function. Here is the example we started with</p><pre class="programlisting">get "/:username" $ do
    username &lt;- param "username"
    html $ mconcat ["&lt;h1&gt; Hello, ", username , "&lt;/h1&gt;"]</pre><p>The action is run in the <code class="literal">ActionT</code> monad. The call to <code class="literal">param</code> leaves
the state unchanged. The call to <code class="literal">html</code>, as seen below, along with
the <code class="literal">raw</code> function updates the state in the <code class="literal">ActionT</code>.</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Action.hs#L285" target="_top">html</a></p><pre class="programlisting">-- | Set the body of the response to the given 'T.Text' value. Also sets \"Content-Type\"
-- header to \"text/html; charset=utf-8\" if it has not already been set.
html :: (ScottyError e, Monad m) =&gt; T.Text -&gt; ActionT e m ()
html t = do
    changeHeader addIfNotPresent "Content-Type" "text/html; charset=utf-8"
    raw $ encodeUtf8 t</pre><p>The <code class="literal">html</code> function adds a header to the response and applies <code class="literal">raw</code>
to the encoded text.</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Action.hs#L305" target="_top">raw</a></p><pre class="programlisting">-- | Set the body of the response to the given 'BL.ByteString' value. Doesn't set the
-- \"Content-Type\" header, so you probably want to do that on your
-- own with 'setHeader'.
raw :: Monad m =&gt; BL.ByteString -&gt; ActionT e m ()
raw =
ActionT . MS.modify . setContent . ContentBuilder . fromLazyByteString</pre><p>Here the <code class="literal">raw</code> function create a <code class="literal">Content</code> value and set the
<code class="literal">srContent</code> attribute of the <code class="literal">ScottyResponse</code> value. Notice, that
<code class="literal">raw</code> has a return type of <code class="literal">ActionT e m ()</code>. This function updates the
<code class="literal">state</code> in <code class="literal">ActionT</code>. The <code class="literal">state</code> in <code class="literal">ActionT</code> is the <code class="literal">response</code> that
is accumulated before it is served.</p><p>Other functions that can be used to send different responses  are as
follows:</p><p><a class="ulink" href="https://github.com/gdevanla/scotty/blob/master/Web/Scotty/Action.hs#L300" target="_top">Functions
to create Response</a></p><pre class="programlisting">-- | Send a file as the response. Doesn't set the \"Content-Type\" header, so you probably
-- want to do that on your own with 'setHeader'.
file :: Monad m =&gt; FilePath -&gt; ActionT e m ()
file = ActionT . MS.modify . setContent . ContentFile

-- | Set the body of the response to the JSON encoding of the given value. Also sets \"Content-Type\"
-- header to \"application/json; charset=utf-8\" if it has not already been set.
json :: (A.ToJSON a, ScottyError e, Monad m) =&gt; a -&gt; ActionT e m ()
json v = do
    changeHeader addIfNotPresent "Content-Type" "application/json; charset=utf-8"
    raw $ A.encode v

-- | Set the body of the response to a Source. Doesn't set the
-- \"Content-Type\" header, so you probably want to do that on your
-- own with 'setHeader'.
stream :: Monad m =&gt; StreamingBody -&gt; ActionT e m ()
stream = ActionT . MS.modify . setContent . ContentStream</pre><p>Therefore, we have seen that having the functions discussed above run
in the <code class="literal">ActionT</code> monad helps them modify the <code class="literal">Response</code> which is
finally returned to the client. These functions, along with the
functions we looked at in the previous chapter, all run in the
<code class="literal">ActionT</code> monad and therefore can <code class="literal">ask</code> for parameters and <code class="literal">modify</code>
the response.</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_epilogue"></a>Chapter 9. Epilogue</h1></div></div></div><p>The Scotty library is a light weight library to build web
applications. It also provides a good introduction to practical
implementation of Haskell based programs. The purpose of this book is
to help the user navigate through the source code of the Scotty
library.</p><p>We started with a toy framework to build up a mental model on the
requirements of the framework and how we could build one. With this we
developed the intuition to understand some of the core functionalities the Scotty library
had to implement to run our sample web application. We looked at the
how the route declarations are handled. Then, we looked at how the
state of the application is initialized. Following that we looked at
the various functions to access the request information. Eventually,
we explored some of the functions that can be used to create the
response that can be served to the client.</p><p>This book does not walk through all the functions implemented in the
Scotty library. But, it attempts to walk through the core functions
that constitute the sequence of calls that occur right from receiving
a request to processing the request and create the response that is
eventually served.</p><p>For more thorough investigation and understanding of the library, the
readers are encouraged to download the Scotty implementation and
explore other aspects of the implementation.</p><p>I hope this short but intense read helped the reader look at a real
world example of Haskell. In addition, I hope this book helped the
reader understand the <code class="literal">Scotty</code> implementation itself.</p></div></div>


  </article>
</section>
    <footer>
        <hr>
        <div class="social">
            <ul>
                <li><a href="http://github.com/gdevanla">GitHub</a></li>
                <li><a href="http://twitter.com/grdvnl">Twitter</a></li>
            </ul>
            <ul>
                <li>
                    Powered by Pelican
                </li>
            </ul>
        </div><!-- /.social -->


<!--  -->

</body>
</html>