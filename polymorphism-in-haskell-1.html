<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="author" content="Guru Devanla">
        <title>Polymorphism in Haskell</title>

        <!--web fonts-->
        <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Belgrano" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="/theme/css/main.css" />
        <link rel="stylesheet" href="/theme/css/pygment.css"/>
        <link rel="stylesheet" href="/theme/css/emacs.css"/>


           <script type="text/javascript">

               var _gaq = _gaq || [];
                 _gaq.push(['_setAccount', 'UA-45968778-1']);
                 _gaq.push(['_trackPageview']);

                 (function() {
                   var ga = document.createElement('script'); ga.type =
                   'text/javascript'; ga.async = true;
                   ga.src = ('https:' == document.location.protocol ?
                   'https://ssl' : 'http://www') +
                   '.google-analytics.com/ga.js';
                   var s = document.getElementsByTagName('script')[0];
                   s.parentNode.insertBefore(ga, s);
                 })();

               </script>

        <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
              Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-45968778-2', 'gdevanla.github.io');
              ga('send', 'pageview');

        </script>
</head>

<body>
    <header>
        <span><a class="title" href="/index.html"><h1>blog <| code </h1></a></span>
        <nav>
            <ul>
                    <li><a href="/index.html">posts</a></li>
                    <li><a href="/archives.html">archives</a></li>
                    <li><a href="/pages/who-am-i.html">about</a></li>
                    <li><a href="/books.html">book</a></li>
            </ul>
        </nav>
    </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h2>
        <a class="title" href="/polymorphism-in-haskell-1.html" rel="bookmark"
           title="Permalink to Polymorphism in Haskell">Polymorphism in Haskell</a></h2>
      <div class="extra-info">
                <abbr class="published" title="2016-09-12T00:00:00-07:00">
                    09-12-2016
                </abbr>
                In <a href="/category/functional-programming-haskell-data-structures.html">functional programming, Haskell, data-structures</a>.       </div><!-- /.entry-content -->

    </header>
    <p>In a dynamic language like Python, there is no strict concept of
function overloading. Though, one can overload operators, function
overloading(other than operators) just means that you shadow the
newest instance of a function (that is functions sharing the <code>same</code>
name) over the old instance.</p>
<p>Function over-loading is also referred to as <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism">ad-hoc polymorphism</a>.
Haskell uses <code>type classes</code> to provide ad-hoc polymorphism.</p>
<p>Ad-hoc polymorphism by way of <code>type classes</code> is much powerful when
compared to function overloading features you get in other static
languages like Java. For a language to support function overloading,
it is required that the runtime know the type of arguments and return
types that is inferred at the call site. This knowledge of types is
used in dispatching the call to the appropriate overloaded function.
Dispatching to methods can be done based on</p>
<ul>
<li>
<p>arguments</p>
</li>
<li>
<p>return type</p>
</li>
<li>
<p>a combination of both.</p>
</li>
</ul>
<p>Not all languages let you do dispatching based on all the above(for example,
in Java, dispatching to overloaded functions is only based on
argument types and not return type. Haskell can do a dispatch to an
function based on the return type as well.</p>
<p>What follows are some example of ad-hoc polymorphism in use. We will assume we are
working with following data types:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    <span class="kr">data</span> <span class="kt">ClassRoom</span> <span class="ow">=</span> <span class="kt">ClassRoom</span> <span class="p">{</span><span class="n">className</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span> <span class="n">studentCount</span><span class="ow">::</span><span class="kt">Int</span><span class="p">}</span>
    <span class="kr">data</span> <span class="kt">SportsTeam</span> <span class="ow">=</span>  <span class="kt">SportsTeam</span> <span class="p">{</span><span class="n">teamName</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span> <span class="n">memberCount</span><span class="ow">::</span><span class="kt">Int</span><span class="p">}</span>
</pre></div>
</td></tr></table>

<h3>Overloading on one argument of a function.</h3>
<p>Say we have the two record types shown above, and we want an overloadeded function
called <code>checkValid</code> to work with both types.</p>
<p>We can use <code>type classes</code> to implement the overloaded functions</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    <span class="c1">-- Wrapped the checkValud function in a type class</span>
    <span class="kr">class</span> <span class="kt">OnOneParameter</span> <span class="n">a</span> <span class="kr">where</span>
      <span class="c1">-- One one parameter</span>
      <span class="n">checkValid</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

    <span class="kr">instance</span> <span class="kt">OnOneParameter</span> <span class="kt">ClassRoom</span> <span class="kr">where</span>
      <span class="n">checkValid</span> <span class="n">v</span> <span class="ow">=</span>  <span class="n">studentCount</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="kr">instance</span> <span class="kt">OnOneParameter</span> <span class="kt">SportsTeam</span> <span class="kr">where</span>
      <span class="n">checkValid</span> <span class="n">v</span> <span class="ow">=</span>  <span class="n">memberCount</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">memberCount</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">10</span>
</pre></div>
</td></tr></table>

<p>This can be easily tested using the below snippet</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    <span class="n">mainp</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
    <span class="n">main</span> <span class="ow">=</span> <span class="kr">do</span>
      <span class="kr">let</span> <span class="n">class_room</span> <span class="ow">=</span> <span class="kt">ClassRoom</span> <span class="p">{</span><span class="n">className</span><span class="ow">=</span><span class="s">&quot;Math&quot;</span><span class="p">,</span> <span class="n">studentCount</span><span class="ow">=</span><span class="mi">10</span><span class="p">}</span>
          <span class="n">sports_team</span> <span class="ow">=</span> <span class="kt">SportsTeam</span> <span class="p">{</span><span class="n">teamName</span><span class="ow">=</span><span class="s">&quot;L&quot;</span><span class="p">,</span> <span class="n">memberCount</span><span class="ow">=</span><span class="mi">6</span><span class="p">}</span>
      <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">checkValid</span> <span class="n">class_room</span>
      <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">checkValid</span> <span class="n">sports_team</span>
</pre></div>
</td></tr></table>

<h3>Overloading on more than one argument.</h3>
<p>If we want to over-load the function with more than one argument, then
we will also have to use <code>MultiParamTypeClasses</code> extension. Using this
extensions, we get the power to dispatch on multiple arguments.</p>
<p>We see that the class definition has two parameters and we can define
three different instances of the <code>checkValidTogether</code> method. Each of
these instances will be called based on the types of both the
arguments at the call site.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    <span class="c1">-- On 2 parameters</span>
    <span class="kr">class</span> <span class="kt">OnTwoParameters</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
      <span class="n">checkValidTogether</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

    <span class="kr">instance</span> <span class="kt">OnTwoParameters</span> <span class="kt">ClassRoom</span> <span class="kt">SportsTeam</span> <span class="kr">where</span>
      <span class="n">checkValidTogether</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">checkValid</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">checkValid</span> <span class="n">b</span>

    <span class="kr">instance</span> <span class="p">(</span><span class="kt">OnOneParameter</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">OnTwoParameters</span> <span class="kt">SportsTeam</span> <span class="n">b</span> <span class="kr">where</span>
      <span class="n">checkValidTogether</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">checkValid</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">checkValid</span> <span class="n">b</span>

    <span class="kr">instance</span> <span class="p">(</span><span class="kt">OnOneParameter</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">OnTwoParameters</span> <span class="kt">ClassRoom</span> <span class="n">b</span> <span class="kr">where</span>
      <span class="n">checkValidTogether</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">checkValid</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">checkValid</span> <span class="n">b</span>

    <span class="n">checkValid2</span> <span class="ow">::</span> <span class="kt">SportsTeam</span> <span class="ow">-&gt;</span> <span class="kt">SportsTeam</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">checkValid2</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">checkValidTogether</span> <span class="n">a</span> <span class="n">b</span>
</pre></div>
</td></tr></table>

<p>One example which is ambiguous is:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    <span class="n">testFn</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">OnOneParameter</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">ClassRoom</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">testFn</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">checkValidTogether</span> <span class="n">a</span> <span class="n">b</span>
</pre></div>
</td></tr></table>

<p>Here the compiler, does not know which version of the overloaded
function should the call be dispatched to. Compiling, the above
snippet will cause the compile to fail with this error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>     <span class="kt">Overlapping</span> <span class="kr">instance</span> <span class="ne">error</span>
     <span class="kt">Overlapping</span> <span class="n">instances</span> <span class="n">for</span> <span class="kt">OnTwoParameters</span> <span class="kt">ClassRoom</span> <span class="n">b</span>
       <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="err">‘</span><span class="n">checkValidTogether</span><span class="err">’</span>
     <span class="kt">Matching</span> <span class="n">instances</span><span class="kt">:</span>
       <span class="kr">instance</span> <span class="kt">OnOneParameter</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">OnTwoParameters</span> <span class="kt">ClassRoom</span> <span class="n">b</span>
          <span class="kt">Defined</span> <span class="n">at</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">flycheck10671M3X</span><span class="o">/</span><span class="kt">Polymorphism</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">40</span><span class="kt">:</span><span class="mi">10</span>
       <span class="kr">instance</span> <span class="kt">OnTwoParameters</span> <span class="kt">ClassRoom</span> <span class="kt">SportsTeam</span>
          <span class="kt">Defined</span> <span class="n">at</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">flycheck10671M3X</span><span class="o">/</span><span class="kt">Polymorphism</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">34</span><span class="kt">:</span><span class="mi">10</span>
</pre></div>
</td></tr></table>

<h3>Overloading on return type</h3>
<p>Here, the function arguments could be the same, but notice that the
dispatch is happening on the return type of the function</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    <span class="kr">class</span> <span class="kt">OnReturnType</span> <span class="n">a</span> <span class="kr">where</span>
      <span class="n">iAmCalledBasedOnReturnType</span> <span class="ow">::</span>  <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span>

    <span class="kr">instance</span> <span class="kt">OnReturnType</span> <span class="kt">Bool</span> <span class="kr">where</span>
      <span class="n">iAmCalledBasedOnReturnType</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>

    <span class="kr">instance</span> <span class="kt">OnReturnType</span> <span class="kt">Int</span> <span class="kr">where</span>
      <span class="n">iAmCalledBasedOnReturnType</span> <span class="kr">_</span> <span class="ow">=</span> <span class="mi">10</span>
</pre></div>
</td></tr></table>

<p>Here is the output, from calling the above functions.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>        <span class="o">&gt;</span> <span class="n">iAmCalledBasedOnReturnType</span> <span class="mi">10</span><span class="ow">::</span><span class="kt">Int</span>
        <span class="mi">10</span>
        <span class="o">&gt;</span> <span class="n">iAmCalledBasedOnReturnType</span> <span class="mi">10</span><span class="ow">::</span><span class="kt">Bool</span>
        <span class="kt">True</span>
        <span class="o">&gt;</span>
</pre></div>
</td></tr></table>

<h3>Overloading functions on both argument types and return type</h3>
<p>This example just builds on the examples we have seen above.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    <span class="kr">class</span> <span class="kt">OnReturnTypeAndParams</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
      <span class="n">iAmCalledBasedOnReturnTypeAndParams</span> <span class="ow">::</span>  <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>

    <span class="kr">instance</span> <span class="kt">OnReturnTypeAndParams</span> <span class="kt">Int</span> <span class="kt">Bool</span> <span class="kr">where</span>
      <span class="n">iAmCalledBasedOnReturnTypeAndParams</span> <span class="n">a</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span>
      <span class="kt">False</span>

    <span class="kr">instance</span> <span class="kt">OnReturnTypeAndParams</span> <span class="kt">Bool</span> <span class="kt">Int</span> <span class="kr">where</span>
      <span class="n">iAmCalledBasedOnReturnTypeAndParams</span> <span class="n">a</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">a</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>
</pre></div>
</td></tr></table>

<p>Here is the output of using the above code</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>        <span class="o">&gt;</span>
        <span class="o">&gt;</span> <span class="kr">let</span> <span class="n">x_int</span> <span class="ow">=</span> <span class="mi">10</span><span class="ow">::</span><span class="kt">Int</span>
        <span class="o">&gt;</span> <span class="n">iAmCalledBasedOnReturnTypeAndParams</span> <span class="n">x_int</span><span class="ow">::</span><span class="kt">Bool</span>
        <span class="kt">False</span>
        <span class="o">&gt;</span> <span class="kr">let</span> <span class="n">y_bool</span> <span class="ow">=</span> <span class="kt">True</span>
        <span class="o">&gt;</span> <span class="n">iAmCalledBasedOnReturnTypeAndParams</span> <span class="n">y_bool</span><span class="ow">::</span><span class="kt">Int</span>
        <span class="mi">1</span>
        <span class="o">&gt;</span>
</pre></div>
</td></tr></table>

<p>By now, we see that Haskell provides constructs that lets us build a
powerful set of abstractions using ad-hoc polmorphism.</p>
<p>As a bonus, here is an example of ad-hoc polymorphism for nested
types:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>        <span class="kr">class</span> <span class="kt">OnNestedType</span> <span class="n">a</span> <span class="kr">where</span>
              <span class="n">nestedType</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>

        <span class="c1">-- Examples of nested types</span>
        <span class="kr">instance</span>  <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">OnNestedType</span>  <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
              <span class="n">nestedType</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">c</span>
</pre></div>
</td></tr></table>


  </article>
</section>
    <footer>
        <hr>
        <div class="social">
            <ul>
                <li><a href="http://github.com/gdevanla">GitHub</a></li>
                <li><a href="http://twitter.com/grdvnl">Twitter</a></li>
            </ul>
            <ul>
                <li>
                    Powered by Pelican
                </li>
            </ul>
        </div><!-- /.social -->


<!--  -->

</body>
</html>