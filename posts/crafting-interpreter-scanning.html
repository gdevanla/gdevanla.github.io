<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>blog <| code - Crafting Interpreters in Haskell - Scanning</title>
        <!--web fonts-->
        <!-- <link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css"> -->
        <!-- <link href="https://fonts.googleapis.com/css?family=Belgrano" rel="stylesheet" type="text/css"> -->

        <link rel="stylesheet" href="../css/main.css" type="text/css" />
        <!-- <link rel="stylesheet" href="/css/default.css" type="test/css"/> -->
        <!-- <link rel="stylesheet" href="/css/syntax.css" type="text/css" /> -->
        <link rel="stylesheet" href="../css/tango.css" type="text/css" />
        <script type="text/javascript">

               var _gaq = _gaq || [];
                 _gaq.push(['_setAccount', 'UA-45968778-1']);
                 _gaq.push(['_trackPageview']);

                 (function() {
                   var ga = document.createElement('script'); ga.type =
                   'text/javascript'; ga.async = true;
                   ga.src = ('https:' == document.location.protocol ?
                   'https://ssl' : 'http://www') +
                   '.google-analytics.com/ga.js';
                   var s = document.getElementsByTagName('script')[0];
                   s.parentNode.insertBefore(ga, s);
                 })();

               </script>

        <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
              Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-45968778-2', 'gdevanla.github.io');
              ga('send', 'pageview');

        </script>

    </head>
    <body>
      <header>
        <span><a class="title" href="../index.html"><h1>blog &lt| code </h1></a></span>
        <nav>
          <ul>
            <li><a href="../index.html">posts</a></li>
            <li><a href="../archive.html">archives</a></li>
            <li><a href="../pages/books.html">RYAS</a></li>
            <li><a href="../about.html">about</a></li>
          </ul>
        </nav>
      </header>
        <main role="main">
            <section id="content" class="body">
  <article>
    <header>
      <h1>Crafting Interpreters in Haskell - Scanning</h1>
      <div class="extra-info">
        <abbr class="published" title="{{ article.date.isoformat() }}">2021-09-11</abbr>
      </div><!-- /.entry-content -->
    </header>
    <section>
        <p>I have started reading this excellent book called <a href="https://craftinginterpreters.com/">Crafting Interpreters</a>. As I read this book, I have decided to implement the <code>Lox</code> intepreter described in this book in Haskell. My goal is to share the implementation and add some commentary for each chapter described in this book.</p>
<p>Note that at times, it might seem like code is duplicated across functions. Often, I have taken this deliberate approach so that the code can be looked at in isolation while describing that piece of code in this tutorial. While I have tests for most of this code, I have not spent time to make it production ready. Therefore, only use this for educational purposes.</p>
<p>In this part of the series, we will be looking at the scanner/lexer implementation for the <code>Lox</code> language. The code will be build in this post will closely reflect the requirements/techniques described in <a href="https://craftinginterpreters.com/scanning.html">Scanning</a> chapter. The code in this series also uses <a href="https://github.com/gdevanla/haskell-lox/blob/main/test/test_lexer.hs">Parsec</a>. Therefore, familiarity with this library is assumed. As a refresher to how this library works, I would recommended walking through examples at <a href="https://jakewheat.github.io/intro_to_parsing/">jakewheat.github.io</a>. I have used many of the techniques described in this tutorial as I built the <code>scanner</code>.</p>
<p>You can find the complete version of this module and related tests at <a href="https://github.com/gdevanla/haskell-lox/blob/main/src/Scanner.hs">Scanner.hs</a> and <a href="https://github.com/gdevanla/haskell-lox/blob/main/test/test_lexer.hs">test_scanner.hs</a>.</p>
<p>The order of implementation closely follows the description in the chapter as much as possible to keep the explanation of the implementation clear. Since we are using <code>Parsec</code> and not directly walking through text our implemenation becomes lot easier. We do not have to maintain state (position of cursor) etc as described in the example. We also use <code>Parsec</code> functionality of looking ahead and making decisions. I think this is reasonable to use <code>Parsec</code> and take advantage of this libary.</p>
<p>Let’s first get some <code>import</code> statements out of the way.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">--- Scanner.hs</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Scanner</span> <span class="kw">where</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Import</span> <span class="kw">hiding</span> (many, (&lt;|&gt;), try)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Char</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Parsec.String</span> <span class="kw">as</span> <span class="dt">PS</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Parsec.Char</span> <span class="kw">as</span> <span class="dt">PC</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Parsec</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">RIO.Partial</span> (read)</span></code></pre></div>
<h1 id="layout">Layout</h1>
<ol type="1">
<li><a href="#error_handling">Error Handling</a></li>
<li><a href="#defining_tokens">Defining Tokens</a></li>
<li><a href="#running_the_scanner">Running the Scanner</a></li>
<li><a href="#single_character_tokens">Single Character Tokens</a></li>
<li><a href="#double_character_tokens">Double Character Tokens</a></li>
<li><a href="#quoted_strings">Quoted Strings</a></li>
<li><a href="#numeric_values">Numeric Values</a></li>
<li><a href="#keywords">Keywords and Identifiers</a></li>
<li><a href="#comments">Single Line Comments</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>
<h1 id="error-handling">Error Handling</h1>
<p><a name="error_handling"></a></p>
<p>Since we are using the <code>Parser</code> we will just use the error reporting functionality provided by <code>Parsec</code>. Therefore, we will define the <code>parser</code> to be of type</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">LoxScannerResult</span> <span class="ot">=</span> <span class="dt">Either</span> <span class="dt">ParseError</span> [<span class="dt">LoxTokInfo</span>]</span></code></pre></div>
<p>We will shortly, talk about what <code>LoxTokInfo</code> will be. The <code>ParserError</code> type is provided by <code>Parsec</code>.</p>
<h1 id="defining-tokens">Defining Tokens</h1>
<p><a name="defining_tokens"></a></p>
<p>Next, we define the <code>tokens</code> of the <code>Lox</code> language that will be captured by the scanner. The <code>enum</code> types nicely translate to a <code>sum</code> type in Haskell.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">LoxTok</span> <span class="ot">=</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="co">-- Single-character tokens.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  <span class="dt">LEFT_PAREN</span><span class="op">|</span> <span class="dt">RIGHT_PAREN</span><span class="op">|</span> <span class="dt">LEFT_BRACE</span><span class="op">|</span> <span class="dt">RIGHT_BRACE</span><span class="op">|</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  <span class="dt">COMMA</span><span class="op">|</span> <span class="dt">DOT</span><span class="op">|</span> <span class="dt">MINUS</span><span class="op">|</span> <span class="dt">PLUS</span><span class="op">|</span> <span class="dt">SEMICOLON</span><span class="op">|</span> <span class="dt">SLASH</span><span class="op">|</span> <span class="dt">STAR</span><span class="op">|</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  <span class="co">-- One or two character tokens.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>  <span class="dt">BANG</span><span class="op">|</span> <span class="dt">BANG_EQUAL</span><span class="op">|</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>  <span class="dt">EQUAL</span><span class="op">|</span> <span class="dt">EQUAL_EQUAL</span><span class="op">|</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>  <span class="dt">GREATER</span><span class="op">|</span> <span class="dt">GREATER_EQUAL</span><span class="op">|</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>  <span class="dt">LESS</span><span class="op">|</span> <span class="dt">LESS_EQUAL</span><span class="op">|</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>  <span class="co">-- Literals/Identifiers/Comments/Numeric values</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>  <span class="dt">IDENTIFIER</span> <span class="dt">String</span><span class="op">|</span> <span class="dt">STRING</span> <span class="dt">String</span><span class="op">|</span> <span class="dt">NUMBER</span> <span class="dt">Double</span><span class="op">|</span> <span class="dt">COMMENT</span> <span class="dt">Text</span><span class="op">|</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>  <span class="co">-- Keywords.</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>  <span class="dt">AND</span><span class="op">|</span> <span class="dt">CLASS</span><span class="op">|</span> <span class="dt">ELSE</span><span class="op">|</span> <span class="dt">FALSE</span><span class="op">|</span> <span class="dt">FUN</span><span class="op">|</span> <span class="dt">FOR</span><span class="op">|</span> <span class="dt">IF</span><span class="op">|</span> <span class="dt">NIL</span><span class="op">|</span> <span class="dt">OR</span><span class="op">|</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>  <span class="dt">PRINT</span><span class="op">|</span> <span class="dt">RETURN</span><span class="op">|</span> <span class="dt">SUPER</span><span class="op">|</span> <span class="dt">THIS</span><span class="op">|</span> <span class="dt">TRUE</span><span class="op">|</span> <span class="dt">VAR</span><span class="op">|</span> <span class="dt">WHILE</span><span class="op">|</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>  <span class="dt">WHITESPACE</span> <span class="co">-- needed to parse end of tokens</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>  <span class="dt">EOF</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>You will notice that the book captures the <code>context</code> around <code>Identifiers</code>, <code>STRING</code> literals, <code>NUMBER</code> inside the <code>Token</code> object. But, we can capture that information as part of the <code>IDENTIFIER</code>, <code>STRING</code>, <code>NUMBER</code> data constructors. Notice, that we also capture single line <code>COMMENT</code> tokens (whereas the example in the book discards them).</p>
<p>Let’s now define our own record which is equivalent to the <code>Token</code> object:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">LoxTokInfo</span> <span class="ot">=</span> <span class="dt">LoxTokInfo</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="ot">  tokinfo_type::</span> <span class="dt">LoxTok</span>,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="ot">  tokinfo_lexeme::</span> <span class="dt">Maybe</span> <span class="dt">T.Text</span>,   <span class="co">-- currently not used</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="ot">  tokinfo_literal::</span> <span class="dt">Maybe</span> <span class="dt">LoxObject</span>, <span class="co">-- currently not used</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="ot">  tok_position::</span> <span class="dt">SourcePos</span>  <span class="co">-- Provided by Parsec</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  }</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>Note, that currently, <code>tokinfo_lexeme</code> and <code>tokinfo_literal</code> are not used. I have left it here to see if I will be needing them in later chapters. For now, the <code>context</code> is captured in the data constructors. For <code>tok_position</code> we are able to just capture the <code>SourcePos</code> type provided by <code>Parsec</code>.</p>
<h1 id="running-the-scanner">Running the scanner</h1>
<p><a name="running_the_scanner"></a></p>
<p>Before we start working on lexing the <code>tokens</code>, let create a helper function that will help us test our scanner in <code>ghci</code> as we build the token parser.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">-- We will fill this function as we progress</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">scanToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>scanToken <span class="ot">=</span> _</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="co">-- public function that will parse the entire input until `eof`</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="ot">scanner ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">LoxScannerResult</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>scanner <span class="ot">=</span>  parse (many scanToken <span class="op">&lt;*</span> eof) <span class="st">&quot;&quot;</span></span></code></pre></div>
<h1 id="recognize-single-character-tokens">Recognize Single Character Tokens</h1>
<p><a name="single_character_tokens"></a></p>
<p>As described by the type <code>LoxTok</code> we have a number of single character tokens to recognize. Since, we want to reuse the scanner implementation, we first create a mapping and then use the mapping to recognize the token.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">charMapping ::</span> [(<span class="dt">LoxTok</span>, <span class="dt">Char</span>)]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>charMapping <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  [ (<span class="dt">LEFT_PAREN</span>, <span class="ch">'('</span>),</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    (<span class="dt">RIGHT_PAREN</span>, <span class="ch">')'</span>),</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    (<span class="dt">LEFT_BRACE</span>, <span class="ch">'{'</span>),</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    (<span class="dt">RIGHT_BRACE</span>, <span class="ch">'}'</span>),</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    (<span class="dt">COMMA</span>, <span class="ch">','</span>),</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    (<span class="dt">DOT</span>, <span class="ch">'.'</span>),</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    (<span class="dt">MINUS</span>, <span class="ch">'-'</span>),</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    (<span class="dt">PLUS</span>, <span class="ch">'+'</span>),</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    (<span class="dt">SEMICOLON</span>, <span class="ch">';'</span>),</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    (<span class="dt">SLASH</span>, <span class="ch">'/'</span>),</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    (<span class="dt">STAR</span>, <span class="ch">'*'</span>),</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    (<span class="dt">BANG</span>, <span class="ch">'!'</span>),</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>    (<span class="dt">EQUAL</span>, <span class="ch">'='</span>),</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    (<span class="dt">GREATER</span>, <span class="ch">'&gt;'</span>),</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>    (<span class="dt">LESS</span>, <span class="ch">'&lt;'</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>  ]</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a><span class="ot">scanSingleCharToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>scanSingleCharToken <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>  source_pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>  sel <span class="ot">&lt;-</span> choice <span class="op">$</span> build <span class="op">&lt;$&gt;</span> charMapping</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">LoxTokInfo</span> sel <span class="dt">Nothing</span> <span class="dt">Nothing</span> source_pos</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a><span class="ot">      build ::</span> (<span class="dt">LoxTok</span>, <span class="dt">Char</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">LoxTok</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>      build (x, y) <span class="ot">=</span> x <span class="op">&lt;$</span> char y <span class="op">&lt;*</span> whitespace</span></code></pre></div>
<p>If we succeed scanning a single character token, the <code>scanSingleCharToken</code> returns <code>LoxTokInfo</code> with a value for the <code>token</code>and also the <code>source_pos</code>. We will follow similar pattern in other <code>scan*</code> functions as well. Lets update the <code>scanToken</code> function with this tokenizer.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">scanToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>scanToken <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  scanSingleCharToken</span></code></pre></div>
<p>Now, lets fire up <code>ghci</code>, with <code>stack ghci</code> and check if our function works:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>λ <span class="op">&gt;&gt;</span><span class="kw">import</span> <span class="dt">Scanner</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>λ <span class="op">&gt;&gt;</span>scanner <span class="st">&quot;{&quot;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="dt">Right</span> [<span class="dt">LoxTokInfo</span> {tokinfo_type <span class="ot">=</span> <span class="dt">LEFT_BRACE</span>, tokinfo_lexeme <span class="ot">=</span> <span class="dt">Nothing</span>, tokinfo_literal <span class="ot">=</span> <span class="dt">Nothing</span>, tok_position <span class="ot">=</span> (line <span class="dv">1</span>, column <span class="dv">1</span>)}]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="ot">it ::</span> <span class="dt">LoxScannerResult</span></span></code></pre></div>
<h1 id="recognizing-double-tokens">Recognizing Double Tokens</h1>
<p><a name="double_character_tokens"></a></p>
<p>As described in the <code>Scanning</code> chapter, we also need to handle tokens such as <code>==</code>, <code>!=</code> etc. The scanner to scan such tokens would be:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">doubleCharMapping ::</span> [(<span class="dt">LoxTok</span>, <span class="dt">String</span>)]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>doubleCharMapping <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  [ (<span class="dt">BANG_EQUAL</span>, <span class="st">&quot;!=&quot;</span>),</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>    (<span class="dt">EQUAL_EQUAL</span>, <span class="st">&quot;==&quot;</span>),</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    (<span class="dt">GREATER_EQUAL</span>, <span class="st">&quot;&gt;=&quot;</span>),</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    (<span class="dt">LESS_EQUAL</span>, <span class="st">&quot;&lt;=&quot;</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  ]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="ot">scanDoubleToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>scanDoubleToken <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>  source_pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  sel <span class="ot">&lt;-</span> choice <span class="op">$</span> build <span class="op">&lt;$&gt;</span> doubleCharMapping</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">LoxTokInfo</span> sel <span class="dt">Nothing</span> <span class="dt">Nothing</span> source_pos</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a><span class="ot">    build ::</span> (<span class="dt">LoxTok</span>, <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">LoxTok</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>    build (x, y) <span class="ot">=</span> x <span class="op">&lt;$</span> string y <span class="op">&lt;*</span> whitespace</span></code></pre></div>
<p>This scanner just differs from the <code>scanSingleCharToken</code> scanner in the <code>mapping</code> it uses. Nevertheless, we duplicate this code and not worry about abstraction. Let’s try this in <code>ghci</code> after updating our <code>scanToken</code> function. Note, that this scanner has to preceed the <code>scanSingleCharToken</code> scanner for us to detect <code>==</code>. Or else, we will end up with to <code>=</code> tokens, and the <code>scanDoubleCharToken</code> would never be invoked.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>λ <span class="op">&gt;&gt;</span>scanner <span class="st">&quot;=&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="dt">Right</span> [<span class="dt">LoxTokInfo</span> {tokinfo_type <span class="ot">=</span> <span class="dt">EQUAL</span>, tokinfo_lexeme <span class="ot">=</span> <span class="dt">Nothing</span>, tokinfo_literal <span class="ot">=</span> <span class="dt">Nothing</span>, tok_position <span class="ot">=</span> (line <span class="dv">1</span>, column <span class="dv">1</span>)}]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="ot">it ::</span> <span class="dt">LoxScannerResult</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>λ <span class="op">&gt;&gt;</span>scanner <span class="st">&quot;==&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="dt">Right</span> [<span class="dt">LoxTokInfo</span> {tokinfo_type <span class="ot">=</span> <span class="dt">EQUAL_EQUAL</span>, tokinfo_lexeme <span class="ot">=</span> <span class="dt">Nothing</span>, tokinfo_literal <span class="ot">=</span> <span class="dt">Nothing</span>, tok_position <span class="ot">=</span> (line <span class="dv">1</span>, column <span class="dv">1</span>)}]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="ot">it ::</span> <span class="dt">LoxScannerResult</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>λ <span class="op">&gt;&gt;</span></span></code></pre></div>
<p>Note, that <code>=</code> scans to <code>EQUAL</code> and <code>==</code> scans to <code>EQUAL_EQUAL</code>.</p>
<h2 id="recognizing-quoted-strings">Recognizing Quoted Strings</h2>
<p><a name="quoted_strings"></a></p>
<p>Recognizing quoted strings getts a little tricky, since one needs to keep track of escape sequences and nested quoted strings. We had a couple of helper functions to just to the same. Note, that I am using this approach from the <a href="https://stackoverflow.com/questions/24106314/parser-for-quoted-string-using-parsec">SO</a> answer noted in the code snippet below. I will skip the explanation for this direct you to the SO answer in this case.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">-- -- https://stackoverflow.com/questions/24106314/parser-for-quoted-string-using-parsec</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="ot">escape ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>escape <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  d <span class="ot">&lt;-</span> char <span class="ch">'\\'</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  c <span class="ot">&lt;-</span> oneOf <span class="st">&quot;\\\&quot;0nrvtbf&quot;</span> <span class="co">-- all the characters which can be escaped</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>  <span class="fu">return</span> [d, c]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="ot">nonEscape ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>nonEscape <span class="ot">=</span> noneOf <span class="st">&quot;\\\&quot;\0\n\r\v\t\b\f&quot;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="ot">character ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>character <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">return</span> nonEscape <span class="op">&lt;|&gt;</span> escape</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a><span class="ot">scanQuotedString ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>scanQuotedString <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>  source_pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>  qstring <span class="ot">&lt;-</span> char <span class="ch">'&quot;'</span> <span class="op">*&gt;</span> many character <span class="op">&lt;*</span> char <span class="ch">'&quot;'</span> <span class="op">&lt;*</span> whitespace</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">LoxTokInfo</span> (<span class="dt">STRING</span> <span class="op">$</span> Import.concat qstring) <span class="dt">Nothing</span> <span class="dt">Nothing</span> source_pos</span></code></pre></div>
<p>Update the <code>scanToken</code> function and let’s try this in <code>ghci</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="ot">scanToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>scanToken <span class="ot">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  try scanDoubleToken</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="op">&lt;|&gt;</span> scanSingleCharToken</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  <span class="op">&lt;|&gt;</span> try scanQuotedString</span></code></pre></div>
<p>Example of quoted string being parsed:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>λ <span class="op">&gt;&gt;</span>scanner <span class="st">&quot;\&quot;test this with \\n newline\&quot;&quot;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="dt">Right</span> [<span class="dt">LoxTokInfo</span> {tokinfo_type <span class="ot">=</span> <span class="dt">STRING</span> <span class="st">&quot;test this with \\n newline&quot;</span>, tokinfo_lexeme <span class="ot">=</span> <span class="dt">Nothing</span>, tokinfo_literal <span class="ot">=</span> <span class="dt">Nothing</span>, tok_position <span class="ot">=</span> (line <span class="dv">1</span>, column <span class="dv">1</span>)}]</span></code></pre></div>
<h1 id="recognizing-numeric-values-we-will-use-doubles-entirely">Recognizing Numeric values (we will use DOUBLES entirely)</h1>
<p><a name="numeric_values"></a></p>
<p>Our next task is to scan strings representing numeric values as `Double. The scanning functions for these would be:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>whitespaceToken <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  source_pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  _ <span class="ot">&lt;-</span> many1 <span class="op">$</span> char <span class="ch">' '</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">LoxTokInfo</span> <span class="dt">WHITESPACE</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span> source_pos</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="ot">scanDouble ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>scanDouble <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>  source_pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>  <span class="kw">let</span> la <span class="ot">=</span> lookAhead (whitespaceToken <span class="op">&lt;|&gt;</span> scanSingleCharToken)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>  sel <span class="ot">&lt;-</span> <span class="kw">do</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>    firstPart <span class="ot">&lt;-</span> Text.Parsec.many1 digit</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>    try (secondCharacter firstPart <span class="op">&lt;*</span> la <span class="op">&lt;*</span> whitespace) <span class="op">&lt;|&gt;</span> <span class="dt">NUMBER</span> (<span class="fu">read</span> firstPart) <span class="op">&lt;$</span> la <span class="op">&lt;*</span> whitespace</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">LoxTokInfo</span> sel <span class="dt">Nothing</span> <span class="dt">Nothing</span> source_pos</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a><span class="ot">    secondCharacter ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">LoxTok</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>    secondCharacter firstPart <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>      void <span class="op">$</span> char <span class="ch">'.'</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>      secondPart <span class="ot">&lt;-</span> Text.Parsec.many1 digit <span class="op">&lt;*</span> whitespace</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a>      <span class="fu">return</span> <span class="op">$</span> <span class="dt">NUMBER</span> <span class="op">$</span> <span class="fu">read</span> <span class="op">$</span> Import.concat [firstPart, <span class="st">&quot;.&quot;</span>, secondPart]</span></code></pre></div>
<p>Again, as described in the book, we need to scan two parts for any numeric value. The string preceding <code>.</code> and the string following the <code>.</code>. Also, the <code>.</code> is optional. In our case, we first scan the string preceding the <code>.</code>, and then optionally call <code>secondCharacter</code> to scan the remaining string if any exists. After updating <code>scanToken</code> we have</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="ot">scanToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>scanToken <span class="ot">=</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>  try scanDoubleToken</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  <span class="op">&lt;|&gt;</span> scanSingleCharToken</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>  <span class="op">&lt;|&gt;</span> try scanQuotedString</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  <span class="op">&lt;|&gt;</span> try scanDouble</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>λ <span class="op">&gt;&gt;</span><span class="fu">fmap</span> tokenShow <span class="op">$</span> fromRight [] <span class="op">$</span> scanner <span class="st">&quot;1.1;&quot;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>[<span class="st">&quot;LoxTok=NUMBER 1.1&quot;</span>,<span class="st">&quot;LoxTok=SEMICOLON&quot;</span>]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="ot">it ::</span> [<span class="dt">String</span>]</span></code></pre></div>
<p>The <code>lookAhead</code> is needed to handle cases where the numeric value is preceeded by non-terminating characters like alpha characters. For example, <code>1.1abc</code>. In this case we want the lexer to fail</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>λ <span class="op">&gt;&gt;</span>scanner <span class="st">&quot;1.1a&quot;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="dt">Left</span> (line <span class="dv">1</span>, column <span class="dv">4</span>)<span class="op">:</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>unexpected <span class="st">&quot;a&quot;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>expecting digit, <span class="st">&quot;(&quot;</span>, <span class="st">&quot;)&quot;</span>, <span class="st">&quot;{&quot;</span>, <span class="st">&quot;}&quot;</span>, <span class="st">&quot;,&quot;</span>, <span class="st">&quot;.&quot;</span>, <span class="st">&quot;-&quot;</span>, <span class="st">&quot;+&quot;</span>, <span class="st">&quot;;&quot;</span>, <span class="st">&quot;/&quot;</span>, <span class="st">&quot;*&quot;</span>, <span class="st">&quot;!&quot;</span>, <span class="st">&quot;=&quot;</span>, <span class="st">&quot;&gt;&quot;</span> <span class="fu">or</span> <span class="st">&quot;&lt;&quot;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="ot">it ::</span> <span class="dt">LoxScannerResult</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>λ <span class="op">&gt;&gt;</span></span></code></pre></div>
<h1 id="recognizing-keywords-and-identifiers">Recognizing Keywords and Identifiers</h1>
<p><a name="keywords"></a></p>
<p>Our code for recognizing key words will be similar to the ones we had to scan character tokens and double character tokens. Similar to our earlier approach, we will use a map to generate all the cases.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">keywordMapping ::</span> [(<span class="dt">LoxTok</span>, <span class="dt">String</span>)]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>keywordMapping <span class="ot">=</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>  [</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    (<span class="dt">AND</span>, <span class="st">&quot;and&quot;</span>),</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>    (<span class="dt">CLASS</span>, <span class="st">&quot;class&quot;</span>),</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>    (<span class="dt">ELSE</span>, <span class="st">&quot;else&quot;</span>),</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>    (<span class="dt">FALSE</span>, <span class="st">&quot;false&quot;</span>),</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>    (<span class="dt">FUN</span>, <span class="st">&quot;fun&quot;</span>),</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>    (<span class="dt">FOR</span>, <span class="st">&quot;for&quot;</span>),</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>    (<span class="dt">IF</span>, <span class="st">&quot;if&quot;</span>),</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>    (<span class="dt">NIL</span>, <span class="st">&quot;nil&quot;</span>),</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>    (<span class="dt">OR</span>, <span class="st">&quot;or&quot;</span>),</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>    (<span class="dt">PRINT</span>, <span class="st">&quot;print&quot;</span>),</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>    (<span class="dt">RETURN</span>, <span class="st">&quot;return&quot;</span>),</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>    (<span class="dt">SUPER</span>, <span class="st">&quot;super&quot;</span>),</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a>    (<span class="dt">THIS</span>, <span class="st">&quot;this&quot;</span>),</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a>    (<span class="dt">TRUE</span>, <span class="st">&quot;true&quot;</span>),</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>    (<span class="dt">VAR</span>, <span class="st">&quot;var&quot;</span>),</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a>    (<span class="dt">WHILE</span>, <span class="st">&quot;while&quot;</span>)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>    ]</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a><span class="ot">scanKeywordToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a>scanKeywordToken <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a>  source_pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a>  sel <span class="ot">&lt;-</span> choice <span class="op">$</span> build <span class="op">&lt;$&gt;</span> keywordMapping</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">LoxTokInfo</span> sel <span class="dt">Nothing</span> <span class="dt">Nothing</span> source_pos</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true"></a><span class="ot">    build ::</span> (<span class="dt">LoxTok</span>, <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">LoxTok</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true"></a>    build (x, y) <span class="ot">=</span> x <span class="op">&lt;$</span> string y <span class="op">&lt;*</span> whitespace</span></code></pre></div>
<p>And, accordingly, let’s update the <code>scanToken</code> function.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">scanToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>scanToken <span class="ot">=</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  try scanDoubleToken</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanSingleCharToken</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanQuotedString</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanDouble</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanKeywordToken</span></code></pre></div>
<p>Testing, this in <code>ghci</code> shows</p>
<pre><code>λ &gt;&gt;scanner &quot;class&quot;
Right [LoxTokInfo {tokinfo_type = CLASS, tokinfo_lexeme = Nothing, tokinfo_literal = Nothing, tok_position = (line 1, column 1)}]
it :: LoxScannerResult</code></pre>
<p>Now, to recoginize <code>Identifiers</code>, we need to make sure they are not <code>prefixes</code> of the <code>keywords</code>. Identifiers also can only start with an alphabet followed by digits and <code>_</code>. We can implement that parser as follows:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- -- http://jakewheat.github.io/intro_to_parsing/#_var</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="ot">var ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>var <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>  fc <span class="ot">&lt;-</span> firstChar</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>  rest <span class="ot">&lt;-</span> many nonFirstChar</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="fu">return</span> (fc <span class="op">:</span> rest)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>    firstChar <span class="ot">=</span> satisfy (\a <span class="ot">-&gt;</span> isLetter a <span class="op">||</span> a <span class="op">==</span> <span class="ch">'_'</span>)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>    nonFirstChar <span class="ot">=</span> satisfy (\a <span class="ot">-&gt;</span> <span class="fu">isDigit</span> a <span class="op">||</span> isLetter a <span class="op">||</span> a <span class="op">==</span> <span class="ch">'_'</span>)</span></code></pre></div>
<p>But, after parsing the identifier, we also need to parse it and make sure they are not <code>keywords</code>. Therefore, we will wrap the <code>var</code> parser into <code>checkIdentifier</code> function.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="ot">checkIfIdentifier ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>checkIfIdentifier <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  source_pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  s <span class="ot">&lt;-</span> var</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  result ([(x, y) <span class="op">|</span> (x, y) <span class="ot">&lt;-</span> keywordMapping, y <span class="op">==</span> s]) s source_pos</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>    result xs s source_pos <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>      <span class="kw">case</span> xs <span class="kw">of</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>        [] <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">LoxTokInfo</span> (<span class="dt">IDENTIFIER</span> s) <span class="dt">Nothing</span> <span class="dt">Nothing</span> source_pos</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>        (x, _)<span class="op">:</span>_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">LoxTokInfo</span> x <span class="dt">Nothing</span> <span class="dt">Nothing</span>  source_pos</span></code></pre></div>
<p>Notice that if the scanned <code>string</code> matches any of the keywords, then we return the <code>keyword</code> else return the string wrapped inside the <code>IDENTIFIER</code>. Once again, lets update the <code>scanToken</code> function</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="ot">scanToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>scanToken <span class="ot">=</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>  try scanDoubleToken</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanSingleCharToken</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanQuotedString</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanDouble</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> checkIfIdentifier</span></code></pre></div>
<h1 id="recognizing-single-line-comments">Recognizing single line comments</h1>
<p><a name="comments"></a></p>
<p>One other addition to the scanner as described in the chapter is to add support to support single line comments. We diverge from chapter and capture the <code>comment</code> inside a <code>COMMENT</code> data constructor.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="ot">scanComment ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>scanComment <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>  source_pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  _ <span class="ot">&lt;-</span> string <span class="st">&quot;//&quot;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>  <span class="co">-- TODO: Find a better way to do this, scanning this more than once is less desirable</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>  comment <span class="ot">&lt;-</span> try (manyTill anyToken (try (oneOf <span class="st">&quot;\n&quot;</span>))) <span class="op">&lt;|&gt;</span> manyTill anyToken eof</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">LoxTokInfo</span> (<span class="dt">COMMENT</span> (T.pack comment)) <span class="dt">Nothing</span> <span class="dt">Nothing</span> source_pos</span></code></pre></div>
<p>The <code>scanComment</code> function could potentially be improved to not do two entire parses when there is comment at the last line of the file. For now, I have let it as is.</p>
<p>The final version of <code>scanToken</code> is as follows. Note, that we need to add <code>scanComment</code> parser before <code>scanSingleCharToken</code>, since the <code>//</code> shares a prefix with <code>/</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="ot">scanToken ::</span> <span class="dt">Parser</span> <span class="dt">LoxTokInfo</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>scanToken <span class="ot">=</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>    try scanComment</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanDoubleToken</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanSingleCharToken</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanQuotedString</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> try scanDouble</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>    <span class="op">&lt;|&gt;</span> checkIfIdentifier</span></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>With the above changes we have scanner replicated in Haskell which can lex a <code>Lox</code> program. Hope you found this useful. See you all in the follow up series.</p>
    </section>
  </article>
</section>

        </main>
    <footer>
        <hr>
        <div class="social">
          <ul>
            <li><a href="https://github.com/gdevanla/">GitHub</a></li>
            <li><a href="https://twitter.com/grdvnl">Twitter</a></li>
            <li><a href="https://www.linkedin.com/in/grdvnl/">LinkedIn</a></li>
          </ul>
          <ul>
              <li>
                Site proudly generated by
                <a href="http://jaspervdj.be/hakyll">Hakyll</a>
                </li>
            </ul>
        </div><!-- /.social -->
    </footer>
    </body>
</html>
